##### 时空复杂度
用于表示算法的时间复杂度和空间复杂度。
##### O(1)
O(1)就是最低的时空复杂度了，耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）。比如酒店的管理员，负责管理酒店的钥匙，把酒店的100把钥匙放在了100个格子里面存着，并且把格子从1~100进行了编号，要拿10号房间的钥匙，则直接从10号格子里面拿出钥匙，速度非常快。
##### O(n)
时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法，要找到一个数组里面最大的一个数，就要把n个变量都扫描对比一遍，操作次数为n，算法复杂度是O(n)。例子：用100个箱子存100把钥匙，因为箱子太浪费空间，然后想了一个办法就是把钥匙贴上编号，然后用绳子串起来。要找出10号房间的钥匙，就需要一个一个去查找，钥匙越多，查找的次数就越多。
##### O(n^2)
就是O括号里面n的2次方，代表数据量增大n倍时，耗时增大n的平方倍。比如冒泡排序排一个数组要双层循环，对于n个变量的数组，需要交换变量位置n^2次，算法复杂度就是O(n^2)。例子：如果有100层楼每层有100个房间，然后有100个用绳子串起来的钥匙串。此时如果要拿到某一把钥匙，就要先找到哪一层楼，再找到房间对应的编号。
##### O(log n)
二分查找就是O(log n)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。例子：100把钥匙，一个一个找太慢了，从中间找，比如要找到23号的房间钥匙，从中间切开，找到50编号的位置，然后23在1~50里面，我再把从中间切开变成25，然后23在1~25之间，我再切开变成12.5，然后23在12.5~25之间，依次找下去，直到找到钥匙。这种查找钥匙的方法的复杂度就是O(log^n)
##### O(n log n)
就是n乘以log n，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于 平方。归并排序就是O(n log n)的时间复杂度。 
