##### 时空复杂度
时间复杂度(运行时间)和空间复杂度(占用空间)是衡量算法好坏的重要指标。时间复杂度用大写的O来表示，具体复杂的程度用括号里面的常量或者对数函数表示。
##### O(1)
O(1)是最低的时空复杂度了，耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）。比如酒店的管理员，负责管理酒店的钥匙，把酒店的100把钥匙放在了100个格子里面存着，并且把格子从1~100进行了编号，要拿10号房间的钥匙，则直接从10号格子里面拿出钥匙，速度非常快。
##### O(n)
时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法，要找到一个数组里面最大的一个数，就要把n个变量都扫描对比一遍，操作次数为n，算法复杂度是O(n)。例子：用100个箱子存100把钥匙，因为箱子太浪费空间，然后想了一个办法就是把钥匙贴上编号，然后用绳子串起来。要找出10号房间的钥匙，就需要一个一个去查找，钥匙越多，查找的次数就越多。
##### O(n^2)
就是O括号里面n的2次方，代表数据量增大n倍时，耗时增大n的平方倍。比如冒泡排序排一个数组要双层循环，对于n个变量的数组，需要交换变量位置n^2次，算法复杂度就是O(n^2)。例子：如果有100层楼每层有100个房间，然后有100个用绳子串起来的钥匙串。此时如果要拿到某一把钥匙，就要先找到哪一层楼，再找到房间对应的编号。
##### O(log n)
二分查找就是O(log n)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。例子：100把钥匙，一个一个找太慢了，从中间找，比如要找到23号的房间钥匙，从中间切开，找到50编号的位置，然后23在1~50里面，我再把从中间切开变成25，然后23在1~25之间，我再切开变成12.5，然后23在12.5~25之间，依次找下去，直到找到钥匙。这种查找钥匙的方法的复杂度就是O(log^n)
##### O(n log n)
就是n乘以log n，当数据增大256倍时，耗时增大256乘以8=2048倍。这个复杂度高于线性低于 平方。归并排序就是O(n log n)的时间复杂度。
例：IO次数取决于B树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，即N=(m+1)h,当数据量N一定的情况下，m越大，h越小。m=磁盘块的大小/数据项的大小，磁盘块的大小大概是一个数据页的大小，固定的，数据项占的空间越小，单个磁盘块容纳的数量越多，树的高度越低
