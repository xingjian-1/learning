## 算法的定义
###### 数学角度算法是用于解决某一类问题的公式和思想。计算机角度算法是一系列程序指令，用于解决特定的运算和逻辑问题。算法研究的目的是为了更有效的处理数据，提高数据运算效率
## 如何衡量算法的好坏
###### 时间复杂度：运行时间长短。空间复杂度：占用内存大小
## 怎么计算时间复杂度
###### 大O表示法（渐进时间复杂度）：把程序的相对执行时间函数T(n)简化为一个数量级，这个数量级可以是n、n^2、logN等。推导时间复杂度的几个原则：如果运行时间是常数量级，则用常数1表示。只保留时间函数中的最高阶项。如果最高阶项存在，则省去最高项前面的系数。时间复杂度对比：O(1) > O(logn) > O(n) > O(nlogn) > O(n^2)。不同时间复杂度算法运行次数对比：<br><img src="/img/20200813142752.jpg" width="70%" hight="50%">
## 怎么计算空间复杂度
###### 常量空间 O(1)：存储空间大小固定，和输入规模没有直接的关系。线性空间 O(n)：分配的空间是一个线性的集合，并且集合大小和输入规模n成正比。二维空间 O(n^2)：分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比。递归空间 O(logn)：递归是一个比较特殊的场景。虽然递归代码中并没有显式的声明变量或集合，但是计算机在执行程序时，会专门分配一块内存空间，用来存储“方法调用栈”。执行递归操作所需要的内存空间和递归的深度成正比
## 如何定义算法的稳定性
###### 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
###### 
## 常用算法
###### `冒泡排序`
    int a[] = { 6, 3, 4, 2, 10, 1 ,8,5,9};
      for (int i = 0; i < a.length - 1; i++) {
        for (int j = 0; j < a.length - 1 - i; j++) {
          if (a[j] > a[j + 1]) {
            int temp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = temp;
          }
        }
      }
###### `选择排序`
      for (int i = 0; i < a.length - 1; i++) {
        for (int j = i + 1; j < a.length; j++) {
          if (a[i] > a[j]) {
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
          }
        }
      }
###### `插入法排序`
    // 插入排序
      for (int i = 0; i < a.length - 1; i++) {
        for (int j = i + 1; j > 0; j--) {
          if (a[j] < a[j - 1]) {
            int temp = a[j];
            a[j] = a[j - 1];
            a[j - 1] = temp;
          }
        }
      }
      
      for (int b : a) {
			System.out.print("" + b);
		}
###### `二分查找法`-比较次数少，查找速度快 但是排序的数组必须是已经排序的
    public static int binarySearch(int a[], int key) {
      int left = 0;
      int right = a.length - 1;
      int mid;
      while (left <= right) {
        mid = (left + right) / 2;
        if (key == a[mid])
          return mid;
        if (key < a[mid])
          right = mid - 1;// right = mid; 可能死循环
        else
          left = mid + 1;// left = mid; 可能死循环
      }
      return -1;
    }
###### `递归`
    public static int Add(int i) {
      if (i <= 100) {
        count += i;
        Add(i + 1);
      }
      return count;
    }
