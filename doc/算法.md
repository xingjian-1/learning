## 算法的定义
###### 数学角度算法是用于解决某一类问题的公式和思想。计算机角度算法是一系列程序指令，用于解决特定的运算和逻辑问题。算法研究的目的是为了更有效的处理数据，提高数据运算效率
## 如何衡量算法的好坏
###### 时间复杂度：运行时间长短。空间复杂度：占用内存大小
## 怎么计算时间复杂度
###### 大O表示法（渐进时间复杂度）：把程序的相对执行时间函数T(n)简化为一个数量级，这个数量级可以是n、n^2、logN等。推导时间复杂度的几个原则：如果运行时间是常数量级，则用常数1表示。只保留时间函数中的最高阶项。如果最高阶项存在，则省去最高项前面的系数。时间复杂度对比：O(1) > O(logn) > O(n) > O(nlogn) > O(n^2)。不同时间复杂度算法运行次数对比：<br><img src="/img/20200813142752.jpg" width="70%" hight="50%">
## 怎么计算空间复杂度
###### 常量空间 O(1)：存储空间大小固定，和输入规模没有直接的关系。线性空间 O(n)：分配的空间是一个线性的集合，并且集合大小和输入规模n成正比。二维空间 O(n^2)：分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比。递归空间 O(logn)：递归是一个比较特殊的场景。虽然递归代码中并没有显式的声明变量或集合，但是计算机在执行程序时，会专门分配一块内存空间，用来存储“方法调用栈”。执行递归操作所需要的内存空间和递归的深度成正比
## 如何定义算法的稳定性
###### 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
## 有哪些常见算法
* 字符串：暴力匹配、BM、KMP、Trie等。
* 查找：二分查找、遍历查找等。
* 排序：冒泡排序、快排、计数排序、堆排序等。
* 搜索：TFIDF、PageRank等。
* 聚类分析：期望最大化、k-meanings、k-数位等。
* 深度学习：深度信念网络、深度卷积神经网络、生成式对抗等。
* 异常检测：k最近邻、局部异常因子等。
* ......
## 十大经典排序算法<br><img src="/img/20200813144023.png" width="70%" hight="50%">
###### `冒泡排序`
###### `实现步骤`比较相邻的元素。1如果第一个比第二个大，就交换它们两个。2对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。3针对所有的元素重复以上的步骤，除了最后一个。4重复步骤1~3，直到排序完成。 <br><img src="/img/20200813152514.jpg" width="70%" hight="50%">
    int a[] = { 6, 3, 4, 2, 10, 1 ,8,5,9};
      for (int i = 0; i < a.length - 1; i++) {
        for (int j = 0; j < a.length - 1 - i; j++) {
          if (a[j] > a[j + 1]) {
            int temp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = temp;
          }
        }
      }
###### `优缺点` 优点：实现和理解简单。缺点：时间复杂度是O(n^2)，排序元素多时效率比较低。
###### `适用范围` 数据已经基本有序，且数据量较小的场景。
###### `场景优化` （1）已经有序了还再继续冒泡问题本轮排序中，元素没有交换，则isSorted为true，直接跳出大循环，避免后续无意义的重复。（2）部分已经有序了，下一轮的时候但还是会被遍历：记录有序和无序数据的边界，有序的部分在下一轮就不用遍历了。（3）只有一个元素不对，但需要走完全部轮排序：鸡尾酒排序：元素的比较和交换是双向的，就像摇晃鸡尾酒一样
###### `选择排序`
      for (int i = 0; i < a.length - 1; i++) {
        for (int j = i + 1; j < a.length; j++) {
          if (a[i] > a[j]) {
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
          }
        }
      }
###### `插入法排序`
    // 插入排序
      for (int i = 0; i < a.length - 1; i++) {
        for (int j = i + 1; j > 0; j--) {
          if (a[j] < a[j - 1]) {
            int temp = a[j];
            a[j] = a[j - 1];
            a[j - 1] = temp;
          }
        }
      }
      
      for (int b : a) {
			System.out.print("" + b);
		}
###### `二分查找法`-比较次数少，查找速度快 但是排序的数组必须是已经排序的
    public static int binarySearch(int a[], int key) {
      int left = 0;
      int right = a.length - 1;
      int mid;
      while (left <= right) {
        mid = (left + right) / 2;
        if (key == a[mid])
          return mid;
        if (key < a[mid])
          right = mid - 1;// right = mid; 可能死循环
        else
          left = mid + 1;// left = mid; 可能死循环
      }
      return -1;
    }
###### `递归`
    public static int Add(int i) {
      if (i <= 100) {
        count += i;
        Add(i + 1);
      }
      return count;
    }
