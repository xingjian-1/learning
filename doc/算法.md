#### 算法的定义
数学角度算法是用于解决某一类问题的公式和思想。计算机角度算法是一系列程序指令，用于解决特定的运算和逻辑问题。算法研究的目的是为了更有效的处理数据，提高数据运算效率
#### 如何衡量算法的好坏
时间复杂度：运行时间长短。空间复杂度：占用内存大小
#### 怎么计算时间复杂度
大O表示法（渐进时间复杂度）：把程序的相对执行时间函数T(n)简化为一个数量级，这个数量级可以是n、n^2、logN等。推导时间复杂度的几个原则：如果运行时间是常数量级，则用常数1表示。只保留时间函数中的最高阶项。如果最高阶项存在，则省去最高项前面的系数。时间复杂度对比：O(1) > O(logn) > O(n) > O(nlogn) > O(n^2)。不同时间复杂度算法运行次数对比：<br><img src="/img/20200813142752.jpg" width="50%" hight="30%">
#### 怎么计算空间复杂度
 常量空间 O(1)：存储空间大小固定，和输入规模没有直接的关系。线性空间 O(n)：分配的空间是一个线性的集合，并且集合大小和输入规模n成正比。二维空间 O(n^2)：分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模n成正比。递归空间 O(logn)：递归是一个比较特殊的场景。虽然递归代码中并没有显式的声明变量或集合，但是计算机在执行程序时，会专门分配一块内存空间，用来存储“方法调用栈”。执行递归操作所需要的内存空间和递归的深度成正比
#### 如何定义算法的稳定性
稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
#### 有哪些常见算法
* 字符串：暴力匹配、BM、KMP、Trie等。
* 查找：二分查找、遍历查找等。
* 排序：冒泡排序、快排、计数排序、堆排序等。
* 搜索：TFIDF、PageRank等。
* 聚类分析：期望最大化、k-meanings、k-数位等。
* 深度学习：深度信念网络、深度卷积神经网络、生成式对抗等。
* 异常检测：k最近邻、局部异常因子等。
* ......
#### 十大经典排序算法<br><img src="/img/20200813144023.png" width="40%" hight="30%">
###### `冒泡排序`
###### `实现步骤`比较相邻的元素。1如果第一个比第二个大，就交换它们两个。2对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数。3针对所有的元素重复以上的步骤，除了最后一个。4重复步骤1~3，直到排序完成。 <br><img src="/img/20200813152514.jpg" width="40%" hight="30%">
    int a[] = { 6, 3, 4, 2, 10, 1 ,8,5,9};
      for (int i = 0; i < a.length - 1; i++) {
        for (int j = 0; j < a.length - 1 - i; j++) {
          if (a[j] > a[j + 1]) {
            int temp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = temp;
          }
        }
      }
###### `优缺点` 优点：实现和理解简单。缺点：时间复杂度是O(n^2)，排序元素多时效率比较低。
###### `适用范围` 数据已经基本有序，且数据量较小的场景。
###### `场景优化` （1）已经有序了还再继续冒泡问题本轮排序中，元素没有交换，则isSorted为true，直接跳出大循环，避免后续无意义的重复。（2）部分已经有序了，下一轮的时候但还是会被遍历：记录有序和无序数据的边界，有序的部分在下一轮就不用遍历了。（3）只有一个元素不对，但需要走完全部轮排序：鸡尾酒排序：元素的比较和交换是双向的，就像摇晃鸡尾酒一样
###### `归并排序`
###### `实现步骤`<br><img src="/img/20200813162724.jpg" width="50%" hight="30%">
###### 把长度为n的输入序列分成两个长度为n/2的子序列。对这两个子序列分别采用归并排序。将两个排序好的子序列合并成一个最终的排序序列
###### `优缺点`优点：性能好且稳定，时间复杂度为O(nlogn) 。稳定排序，适用场景更多。缺点：非原地排序，空间复杂度高。
###### `适用范围` 大数据量且期望要求排序稳定的场景。
###### `快速排序`
###### `实现步骤`<br><img src="/img/20200813163853.png" width="30%" hight="30%">
###### 从数列中挑出一个元素，称为 “基准值”（pivot）。重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。递归地对【小于基准值元素的子数列】和【大于基准值元素的子数列】进行排序。
###### `优缺点`优点：性能较好，时间复杂度最好为O(nlogn)，大多数场景性能都接近最优。原地排序，时间复杂度优于归并排序。缺点：部分场景，排序性能最差为O(n^2)。不稳定排序。
###### `适用范围` 大数据量且不要求排序稳定的场景。
###### `场景优化`（1）每次的基准元素都选中最大或最小元素随机选择基准元素，而不是选择第一个元素。三数取中法，随机选择三个数，取中间数为基准元素。（2）数列含有大量重复数据大于、小于、等于基准值。（3）快排的性能优化双轴快排：2个基准数，例子：Arrays.sort() 。
###### `堆排序(Heapsort)`
###### `实现步骤`<br><img src="/img/20200813164221.png" width="50%" hight="40%">
###### 将初始待排序关键字序列(R1,R2….Rn)构建成最大堆，此堆为初始的无序区。将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]。由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成
###### `优缺点`优点：性能较好，时间复杂度为O(nlogn)。时间复杂度比较稳定。辅助空间复杂度为O(1)。缺点：数据变动的情况下，堆的维护成本较高。
###### `适用范围` 数据量大且数据呈流式输入的场景。
###### `为什么实际情况快排比堆排快`堆排序的过程可知，建立最大堆后，会将堆顶的元素和最后一个元素对调，然后让那最后一个元素从顶上往下沉到恰当的位置，因为底部的元素一定是比较小的，下沉的过程中会进行大量的近乎无效的比较。所以堆排虽然和快排一样复杂度都是O(NlogN)，但堆排复杂度的常系数更大。
###### `计数排序`
###### `实现步骤`<br><img src="/img/20200813165022.png" width="30%" hight="20%">
###### 找出待排序的数组中最大元素。构建一个数组C，长度为最大元素值+1。遍历无序的随机数列，每一个整数按照其值对号入座，对应数组下标的值加1。遍历数组C，输出数组元素的下标值，元素的值是几就输出几次
###### `优缺点`优点：性能完爆比较排序，时间复杂度为O(n+k)，k为数列最大值。稳定排序。缺点：适用范围比较狭窄。
###### `适用范围` 数列元素是整数，当k不是很大且序列比较集中时适用。
###### `场景优化`（1）数字不是从0开始，会存在空间浪费的问题 数列的最小值作为偏移量，以数列最大值-最小值+1作为统计数组的长度。
###### `桶排序`
###### `实现步骤`<br><img src="/img/20200813165310.png" width="30%" hight="20%">
###### 创建桶，区间跨度=(最大值-最小值)/(桶的数量-1)。遍历数列，对号入座。每个桶内进行排序，可选择快排等。遍历所有的桶，输出所有元素。
###### `优缺点`优点：最优时间复杂度为O(n)，完爆比较排序算法。缺点：适用范围比较狭窄。时间复杂度不稳定。
###### `适用范围` 数据服从均匀分布的场景。
###### `选择排序`
      for (int i = 0; i < a.length - 1; i++) {
        for (int j = i + 1; j < a.length; j++) {
          if (a[i] > a[j]) {
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
          }
        }
      }
###### `插入法排序`
    // 插入排序
      for (int i = 0; i < a.length - 1; i++) {
        for (int j = i + 1; j > 0; j--) {
          if (a[j] < a[j - 1]) {
            int temp = a[j];
            a[j] = a[j - 1];
            a[j - 1] = temp;
          }
        }
      }
      
      for (int b : a) {
			System.out.print("" + b);
		}
###### `二分查找法`-比较次数少，查找速度快 但是排序的数组必须是已经排序的
    public static int binarySearch(int a[], int key) {
      int left = 0;
      int right = a.length - 1;
      int mid;
      while (left <= right) {
        mid = (left + right) / 2;
        if (key == a[mid])
          return mid;
        if (key < a[mid])
          right = mid - 1;// right = mid; 可能死循环
        else
          left = mid + 1;// left = mid; 可能死循环
      }
      return -1;
    }
###### `递归`
    public static int Add(int i) {
      if (i <= 100) {
        count += i;
        Add(i + 1);
      }
      return count;
    }
###### `性能对比` 随机生成区间0 ~ K之间的序列，共计N个数字，利用各种算法进行排序，记录排序所需时间。<br><img src="/img/20200813165618.png" width="60%" hight="40%">
