
##### 外观模式(Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是外观模式的应用。

        //定义一个接口：
        public interface Shape {
           void draw();
        }
        //定义几个实现类：
        public class Circle implements Shape {
            @Override
            public void draw() {
               System.out.println("Circle::draw()");
            }
        }

        public class Rectangle implements Shape {
            @Override
            public void draw() {
               System.out.println("Rectangle::draw()");
            }
        }
        //客户端调用：
        public static void main(String[] args) {
            // 画一个圆形
              Shape circle = new Circle();
              circle.draw();

              // 画一个长方形
              Shape rectangle = new Rectangle();
              rectangle.draw();
        }
以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。用外观模式实现如下：

      //我们先定义一个门面：
      public class ShapeMaker {
         private Shape circle;
         private Shape rectangle;
         private Shape square;

         public ShapeMaker() {
            circle = new Circle();
            rectangle = new Rectangle();
            square = new Square();
         }

        //下面定义一堆方法，具体应该调用什么方法，由这个门面来决定
         public void drawCircle(){
            circle.draw();
         }
         public void drawRectangle(){
            rectangle.draw();
         }
         public void drawSquare(){
            square.draw();
         }
      }
      //客户端调用：
      public static void main(String[] args) {
        ShapeMaker shapeMaker = new ShapeMaker();

        // 客户端调用现在更加清晰了
        shapeMaker.drawCircle();
        shapeMaker.drawRectangle();
        shapeMaker.drawSquare();        
      }
门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。
组
