#### 索引是什么
索引(Index)是高效获取数据,快速查找排好序的一种数据结构。通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，目的在于提高查询效率 例如：看书时查找到上次阅读到的节点，先定位到章，然后定位到该章下的一个小节，然后找到页数。
#### 索引有哪些
聚集索引(Clustered Index)也叫聚簇索引，聚集索引的索引列就是主键，所以也叫主键索引，一个表中只有一个聚集索引。非聚集索引(Secondary Index)也叫做非聚簇索引，指的是非叶子节点按照索引的关键值顺序存放，叶子节点存放索引关键值以及对应的主键键值。然后根据主键键值去聚集索引去查询具体数据。
* 主键索引(primary key)：加速查询+列值唯一（不可以有null）
* 唯一索引(unique):加速查询+列值唯一（可以有null），如果是组合索引，则列值的组合必须唯一，CREATE UNIQUE INDEX index_name ON user(name);
* 普通索引(index):仅加速查询,CREATE INDEX index_name ON user(name);
* 联合索引
多列值组成一个索引，专门用于组合搜索，其效率大于索引合并，查询条件中使用了创建索引时的第一个字段，索引才会生效，遵循最左前缀原则。

            -primary key(stu_id,course_id):联合主键索引，对两个外键id做联合主键
            -unique(stu_id,course_id):联合唯一索引,对两个外键id做唯一索引
            -index(id,name):联合普通索引
* B+树索引(B+Tree)
* 哈希索引(Hash)
不是按照索引顺序存储的，无法用于排序。
* 全文索引(Full-text Search)：对文本的内容进行分词，进行搜索，CREATE FULLTEXT INDEX index_article_contents ON 
* 空间索引(spatial)
#### 索引创建原则
* 最少空间原则
指的是列的长度小，长度越小的列，占的空间就越小，B+Tree每个节点的关键字存的就越多，I/O读写次数越少，查询的效率就会越高。
* 高离散度列原则
数据表中列的离散度公式：count(distinct(列名称))/count(*)

就是列的所有不相同的值和所有数据记录总行数的比，值越接近1，离散度就越好。列的重复值越多，离散度越低，重复值越少，离散度越就越高。就像不要在性别字段列上建立索引一样，性别字段列的值除了男就是女，列的离散度太低，建立索引起不到效果，查询优化器选择执行计划可能觉得走这样的索引还不如走全表扫描。
* 最左匹配原则
查询条件中使用了创建索引时的第一个字段，索引才会生效。
#### 索引失效条件
* 查询条件中有or、>、<、between、in、not in、like查询是以%开头的索引失效。

        explain select * from order where id =66;  查询出来的key:primary 为主键索引，
        explain select * from order where id =66 or userid =66; 查出来key值为null，索引失效。
        explain select * from order where user_name like '%德'; 查出来key值为null，索引失效。
        explain select * from table where type like '动物%'; ”%“在后面索引起作用 
        explain select * from table where type=1; 查询结果rows列的值是1，说明此查询语句扫描了1条记录

        查看索引的使用情况：show status like ‘Handler_read%'；
        handler_read_key:这个值表示使用索引查询到的次数；
        handler_read_rnd_next:这个值越大，说明查询越低效；
* 对于null值的列加索引，索引不生效。查询条件中如果对字段进行了null值判断，也会失效。
                
        例如：select id from t where num is null
        只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，
        那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。
* 不要在列上进行运算，where子句中对字段进行函数操作或者表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

        select id from t where substring(name,1,3)='abc' --–name以abc开头的id
        select id from t where num/2=100 
#### 索引的好处
* 快速查找数据。
* 保证数据的唯一性。
* 实现表与表之间的参照完整性。
* 在使用order by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。
#### 索引的缺点
* 索引需要占物理空间。
* 对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会影响性能。
#### 索引原理
给一张空表创建索引时，数据库系统会分配一个索引页，该索引页在往表里面插入数据前是空的。此页此时既是根结点，也是叶结点。每当你往表中插入一行数据，数据库系统即向此根结点中插入一行索引记录。当根结点满时，数据库系统大抵按以下步骤进行分裂：

    创建两个儿子结点
    将原根结点中的数据近似地拆成两半，分别写入新的两个儿子结点
    根结点中加上指向两个儿子结点的指针
#### 索引设计的原则
* 表的某个字段值得离散度越高，该字段越适合选作索引的关键字。主键字段以及唯一性约束字段适合选作索引的关键字，原因就是这些字段的值非常离散。
* 占用存储空间少的字段更适合选作索引的关键字。例如，与字符串相比，整数字段占用的存储空间较少，因此，较为适合选作索引关键字。
* 存储空间固定的字段更适合选作索引的关键字。与text类型的字段相比，char类型的字段较为适合选作索引关键字。
* Where 子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。
* 更新频繁的字段不适合创建索引，不会出现在where子句中的字段不应该创建索引。
* 最左前缀原则。
* 尽量使用前缀索引。
#### 索引
磁盘IO
每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO

基于主键索引和普通索引的查询有什么区别？

如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。


扇区：磁盘的最小存储单位；
磁盘块：文件系统读写数据的最小单位；
页：内存的最小存储单位；

B+树的性质：
1.索引字段要尽量的小：IO次数取决于B树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，即N=(m+1)h,当数据量N一定的情况下，m越大，h越小。m=磁盘块的大小/数据项的大小，磁盘块的大小大概是一个数据页的大小，固定的，数据项占的空间越小，单个磁盘块容纳的数量越多，树的高度越低。索引字段尽量小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项数量会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。<br>
2.索引的最左匹配特性（即从左往右匹配）：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

