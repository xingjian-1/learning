#### 索引
MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，目的在于提高查询效率 例如：看书时查找到上次阅读到的节点，先定位到章，然后定位到该章下的一个小节，然后找到页数。查字典、查火车车次、飞机航班等。
#### 索引分类
* 聚集索引：一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是「平衡树」结构，整个表就变成了一个索引。也就是所谓的「聚集索引」。 一个表只能有一个主键， 一个表只能有一个聚集索引，主键的作用就是把表的数据格式转换成索引（平衡树）的格式放置。
* 非聚集索引：对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据表行数据量一致。
#### 索引类型
* 普通索引index :加速查找 CREATE INDEX index_mytable_name ON mytable(name);
* 唯一索引 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。CREATE UNIQUE INDEX index_mytable_name ON mytable(name);
    主键索引：primary key ：加速查找+约束（不为空且唯一）
    唯一索引：unique：加速查找+约束 （唯一）
* 联合索引 指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。CREATE INDEX index_mytable_id_name ON mytable(id,name);
    -primary key(id,name):联合主键索引
    -unique(id,name):联合唯一索引
    -index(id,name):联合普通索引
* 全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。CREATE FULLTEXT INDEX index_article_contents ON 
* 空间索引spatial :了解就好，几乎不用

##### 索引的好处
* 快速查找数据。
* 保证数据的唯一性。
* 实现表与表之间的参照完整性。
* 在使用order by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。
##### 索引的缺点
* 索引需要占物理空间。
* 对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会影响性能。
#### 索引的创建原则
索引不是越多越好，太多的索引反而会影响数据库的性能。
* 最少空间原则
最少空间指的是列的长度小，长度越小的列，B+Tree 的路数就会越多，IO 检索的次数就会越少，查询的效率就会越高，也就是说索引的效果越好。如果不理解，请再看一下索引的数据结构部分的内容。
* 高离散度列原则
数据表中列的离散度公式：count(distinct(列名称)) / count(*)，也就是列的所有不相同的值和所有数据记录总行数的比，如果列的所有不相同的值和数据记录总行数越接近，那么列的离散度越好，简单来说，如果列的重复值越多，离散度越低，重复值越少，离散度越就越高。这也就是大家都了解的不要再性别字段上建立索引的主要原因，因为性别字段列的值除了男就是女，列的离散型太差，建立索引起不到效果，查询优化器选择执行计划可能觉得走这样的索引还不如走全表扫描。因此我们在创建索引的时候尽量选择离散度高的列，也就是选择列的值几乎没有重复的列做索引效果最好。
* 最左匹配原则
最左匹配原则一般用于联合索引中，联合索引在 B+Tree 中是复合的数据结构，最左匹配原则就是联合索引的检索比对是从左往右匹配的，它是按照从左到右的顺序来建立搜索树的。
假如一张表用手机号和时间联合索引【phone，time】，没有建立 time 的单列索引。那么联合索引【phone，time】（phone 在左边，time 在右边），就表示：phone 是有序的，time 是无序的；当 phone 相等的时候，time 才是有序的。这个时候我们使用 phone 和 time 作为查询条件的时候，B+Tree 会优先比较 phone 来确定下一步应该搜索的方向，往左还是往右；如果 phone 相同的时候再比较 time ；但是如果查询条件只有 time，那么就不知道第一步应该查哪个节点，因为建立搜索树的时候 phone 是在左边，所以用 time 查询就不会用到索引。如果用 phone 作为查询条件，是否可以用到索引呢，答案是肯定的，因为 phone 在联合索引的左边，所以用 phone 独立查询，按照最左匹配原则是可以用到索引的。从最左匹配原则我们就能发现，如果创建了联合索引【phone，time】，那么就没有必要再去创建单列索引【phone】了，但是如果有用 time 作为查询条件的情况，就需要创建 time 列的索引【time】。
#### 索引失效条件
* 查询条件中有or的，索引失效。 如果让索引生效，只能将or条件中的每个列都加上索引
    
      explain select * from order where id =66;查询出来的key:primary 为主键索引，
      explain select * from order where id =66 or userid =66;查出来key值为null，索引失效。
* like查询是以%开头的，索引失效

      explain select * from order where user_name like '%德';查出来key值为null，索引失效
* 如果mysql估计使用全表扫描要比使用索引快，则不使用索引。例如，使用<>、not in 、not exist，对于这三种情况大多数情况下认为结果集很大，MySQL就有可能不使用索引。

      查看索引的使用情况：show status like ‘Handler_read%'；
      handler_read_key:这个值表示使用索引查询到的次数；
      handler_read_rnd_next:这个值越大，说明查询越低效；
      #### MySQL索引
索引是高效获取数据的一种数据结构。验证索引是否生效：

      explain select * from table where type=1 查询结果rows列的值是1，说明此查询语句扫描了1条记录
* 使用模糊查询，”%“在前面时索引不起作用 explain select * from table where type like '%动物'
* 使用模糊查询，”%“在后面索引起作用 explain select * from table where type like '动物%'
* 条件查询中使用or关键字时 索引不起作用，> < between等这样的范围查询 索引不起作用
  
      select id from t where num=10 or num=20 不起作用
      可以改为：select id from t where num=10 union all select id from t where num=20
* 最左原则：c1,c2,c3,c4，c3字段使用索引的前提是c1，c2两字段均使用了索引
* 索引无法存储null值，所以where的判断条件如果对字段进行了null值判断，将导致数据库放弃索引而进行全表查询，如

      select id from t where num is null 
        a.单列索引无法储null值，复合索引无法储全为null的值。
        b.查询时，采用is null条件时，不能利用到索引，只能全表扫描
        
* in 和 not in 也要慎用，否则会导致全表扫描
* 应尽量避免在where子句中对字段进行函数操作或者表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

        select id from t where substring(name,1,3)='abc' --–name以abc开头的id
        select id from t where num/2=100 
 

#### 索引原理
给一张空表创建索引时，数据库系统会分配一个索引页，该索引页在往表里面插入数据前是空的。此页此时既是根结点，也是叶结点。每当你往表中插入一行数据，数据库系统即向此根结点中插入一行索引记录。当根结点满时，数据库系统大抵按以下步骤进行分裂：

    创建两个儿子结点
    将原根结点中的数据近似地拆成两半，分别写入新的两个儿子结点
    根结点中加上指向两个儿子结点的指针
#### 索引设计的原则
* 表的某个字段值得离散度越高，该字段越适合选作索引的关键字。主键字段以及唯一性约束字段适合选作索引的关键字，原因就是这些字段的值非常离散。
* 占用存储空间少的字段更适合选作索引的关键字。例如，与字符串相比，整数字段占用的存储空间较少，因此，较为适合选作索引关键字。
* 存储空间固定的字段更适合选作索引的关键字。与text类型的字段相比，char类型的字段较为适合选作索引关键字。
* Where 子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。
* 更新频繁的字段不适合创建索引，不会出现在where子句中的字段不应该创建索引。
* 最左前缀原则。
* 尽量使用前缀索引。
#### 索引
磁盘IO
每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO

基于主键索引和普通索引的查询有什么区别？

如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。


扇区：磁盘的最小存储单位；
磁盘块：文件系统读写数据的最小单位；
页：内存的最小存储单位；

B+树的性质：
1.索引字段要尽量的小：IO次数取决于B树的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，即N=(m+1)h,当数据量N一定的情况下，m越大，h越小。m=磁盘块的大小/数据项的大小，磁盘块的大小大概是一个数据页的大小，固定的，数据项占的空间越小，单个磁盘块容纳的数量越多，树的高度越低。索引字段尽量小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项数量会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。<br>
2.索引的最左匹配特性（即从左往右匹配）：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

