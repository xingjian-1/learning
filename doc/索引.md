#### 索引
MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构的索引(B+Tree索引)。
#### 索引分类
* 聚集索引：对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。在聚集索引中，叶结点也即数据结点，所有数据行的存储顺序与索引的存储顺序一致
* 非聚集索引：对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页，其行数量与数据表行数据量一致。
#### 索引类型
* 普通索引
最基本的索引，它没有任何限制，用于加速查询。CREATE INDEX index_mytable_name ON mytable(name);
* 唯一索引
索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。CREATE UNIQUE INDEX index_mytable_name ON mytable(name);
* 主键索引
是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。建表的时候一起创建
CREATE TABLE mytable ( `id` int(11) NOT NULL AUTO_INCREMENT , `name` VARCHAR(32) , PRIMARY KEY (`id`) );
* 组合索引
指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。CREATE INDEX index_mytable_id_name ON mytable(id,name);
* 全文索引
主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。CREATE FULLTEXT INDEX index_article_contents ON article(contents);
#### 索引的好处
* 索引可以避免全表扫描。多数查询仅扫描少量索引页及数据页，而不是遍历所有数据页。
* 对于非聚集索引，有些查询甚至可以不访问数据页。
* 聚集索引可以避免数据插入操作集中于表的最后一个数据页。
* 一些情况下，索引还可用于避免排序操作。
#### 索引的创建原则
索引不是越多越好，太多的索引反而会影响数据库的性能。
* 最少空间原则
最少空间指的是列的长度小，长度越小的列，B+Tree 的路数就会越多，IO 检索的次数就会越少，查询的效率就会越高，也就是说索引的效果越好。如果不理解，请再看一下索引的数据结构部分的内容。
* 高离散度列原则
数据表中列的离散度公式：count(distinct(列名称)) / count(*)，也就是列的所有不相同的值和所有数据记录总行数的比，如果列的所有不相同的值和数据记录总行数越接近，那么列的离散度越好，简单来说，如果列的重复值越多，离散度越低，重复值越少，离散度越就越高。这也就是大家都了解的不要再性别字段上建立索引的主要原因，因为性别字段列的值除了男就是女，列的离散型太差，建立索引起不到效果，查询优化器选择执行计划可能觉得走这样的索引还不如走全表扫描。因此我们在创建索引的时候尽量选择离散度高的列，也就是选择列的值几乎没有重复的列做索引效果最好。
* 最左匹配原则
最左匹配原则一般用于联合索引中，联合索引在 B+Tree 中是复合的数据结构，最左匹配原则就是联合索引的检索比对是从左往右匹配的，它是按照从左到右的顺序来建立搜索树的。
假如一张表用手机号和时间联合索引【phone，time】，没有建立 time 的单列索引。那么联合索引【phone，time】（phone 在左边，time 在右边），就表示：phone 是有序的，time 是无序的；当 phone 相等的时候，time 才是有序的。这个时候我们使用 phone 和 time 作为查询条件的时候，B+Tree 会优先比较 phone 来确定下一步应该搜索的方向，往左还是往右；如果 phone 相同的时候再比较 time ；但是如果查询条件只有 time，那么就不知道第一步应该查哪个节点，因为建立搜索树的时候 phone 是在左边，所以用 time 查询就不会用到索引。如果用 phone 作为查询条件，是否可以用到索引呢，答案是肯定的，因为 phone 在联合索引的左边，所以用 phone 独立查询，按照最左匹配原则是可以用到索引的。从最左匹配原则我们就能发现，如果创建了联合索引【phone，time】，那么就没有必要再去创建单列索引【phone】了，但是如果有用 time 作为查询条件的情况，就需要创建 time 列的索引【time】。
#### 索引失效条件
* 查询条件中有or的，索引失效。 如果让索引生效，只能将or条件中的每个列都加上索引
    
      explain select * from order where id =66;查询出来的key:primary 为主键索引，
      explain select * from order where id =66 or userid =66;查出来key值为null，索引失效。
* like查询是以%开头的，索引失效

      explain select * from order where user_name like '%德';查出来key值为null，索引失效
* 如果mysql估计使用全表扫描要比使用索引快，则不使用索引。例如，使用<>、not in 、not exist，对于这三种情况大多数情况下认为结果集很大，MySQL就有可能不使用索引。

      查看索引的使用情况：show status like ‘Handler_read%'；
      handler_read_key:这个值表示使用索引查询到的次数；
      handler_read_rnd_next:这个值越大，说明查询越低效；
      #### MySQL索引
索引是高效获取数据的一种数据结构。验证索引是否生效：

      explain select * from table where type=1 查询结果rows列的值是1，说明此查询语句扫描了1条记录
* 使用模糊查询，”%“在前面时索引不起作用 explain select * from table where type like '%动物'
* 使用模糊查询，”%“在后面索引起作用 explain select * from table where type like '动物%'
* 条件查询中使用or关键字时 索引不起作用，> < between等这样的范围查询 索引不起作用
  
      select id from t where num=10 or num=20 不起作用
      可以改为：select id from t where num=10 union all select id from t where num=20
* 最左原则：c1,c2,c3,c4，c3字段使用索引的前提是c1，c2两字段均使用了索引
* 索引无法存储null值，所以where的判断条件如果对字段进行了null值判断，将导致数据库放弃索引而进行全表查询，如

      select id from t where num is null 
        a.单列索引无法储null值，复合索引无法储全为null的值。
        b.查询时，采用is null条件时，不能利用到索引，只能全表扫描
        
* in 和 not in 也要慎用，否则会导致全表扫描
* 应尽量避免在where子句中对字段进行函数操作或者表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

        select id from t where substring(name,1,3)='abc' --–name以abc开头的id
        select id from t where num/2=100 
 

#### 索引原理
给一张空表创建索引时，数据库系统会分配一个索引页，该索引页在往表里面插入数据前是空的。此页此时既是根结点，也是叶结点。每当你往表中插入一行数据，数据库系统即向此根结点中插入一行索引记录。当根结点满时，数据库系统大抵按以下步骤进行分裂：

    创建两个儿子结点
    将原根结点中的数据近似地拆成两半，分别写入新的两个儿子结点
    根结点中加上指向两个儿子结点的指针
#### 索引设计的原则
* 表的某个字段值得离散度越高，该字段越适合选作索引的关键字。主键字段以及唯一性约束字段适合选作索引的关键字，原因就是这些字段的值非常离散。
* 占用存储空间少的字段更适合选作索引的关键字。例如，与字符串相比，整数字段占用的存储空间较少，因此，较为适合选作索引关键字。
* 存储空间固定的字段更适合选作索引的关键字。与text类型的字段相比，char类型的字段较为适合选作索引关键字。
* Where 子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。
* 更新频繁的字段不适合创建索引，不会出现在where子句中的字段不应该创建索引。
* 最左前缀原则。
* 尽量使用前缀索引。
