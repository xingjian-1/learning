
RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的
RabbitMQ 的高可用性
#### 单机模式
  单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的😄，生产不会用单机模式。
  
#### 普通集群模式（无高可用性）
  普通集群模式，就是在多台机器上启动多个RabbitMQ 实例，每个机器启动一个。你创建的queue，只会放在一个RabbitMQ实例上，但是每个实例都同步queue的元数据。
  没做到分布式。

#### 镜像集群模式（高可用性）
  在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，
  包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。
  
  那么如何开启这个镜像集群模式呢？在RabbitMQ的管理控制台，新增一个镜像集群模式的策略，
  指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。
  
  RabbitMQ镜像集群缺点：
  性能开销大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！
  不是分布式的，就没有扩展性可言了，如果某个queue 负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue。
  如果这个queue的数据量很大，大到这个机器上的容量无法容纳了，此时怎么办？
  
  Kafka 的高可用性
  由多个broker组成，每个broker是一个节点；你创建一个topic，这个topic可以划分为多个partition，每个partition可以存在于不同的broker上，
  每个partition 就放一部分数据。
  这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。
  
  实际上RabbitMQ之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，
  因为无论怎么玩儿，RabbitMQ 一个queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个queue的完整数据。
  
  Kafka0.8以后，提供了HA机制，就是replica（复制品）副本机制。每个partition 的数据都会同步到其它机器上，形成自己的多个replica 副本。所有replica 
  会选举一个leader出来，那么生产和消费都跟这个leader打交道，然后其他replica就是follower。写的时候，leader会负责把数据同步到所有follower上去，
  读的时候就直接读leader上的数据即可。
  
  写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己主动从leader来pull数据。
  一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有follower的ack之后，就会返回写成功的消息给生产者。
  （当然，这只是其中一种模式，还可以适当调整这个行为）
消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。
