#### 场景
有一批数据需要作缓存处理，设计了两种实现方式,一个是内存缓存和一个是磁盘缓存,然后具体有哪些操作、怎么操作需要在接口里面有一个统一的规范（缓存数据的添加、缓存数据的获取，需要传什么样的参数、返回哪些数据等等)，设计模式中简单工厂模式、工厂方法模式、抽象工厂模式实现如下：
##### 简单工厂模式
描述:接口(IOHandler)里面定义两个缓存方式：内存缓存、磁盘缓存,分别对应两个实现类，创建工厂类，定义一个方法返回不同的实现对象。如下：

                 public interface IOHandlerService {
                          void save(String key, String value);
                          String getString(String key);
                 }
                 //内存缓存实现
                 public class MemoryIOHandlerImpl implements IOHandlerService {
                          @Override
                          public void save(String key, String value) {
                                System.out.println(key + "" + value);
                          }
                          @Override
                          public String getString(String key) {
                                return null;
                          }
                 }
                 //磁盘缓存实现
                 public class DiskIOHandlerImpl implements IOHandlerService{
                          @Override
                          public void save(String key, String value) {
                          }      
                          @Override
                          public String getString(String key) {
                                return null;
                          }
                 }
                 /**
                  * @Description工厂类
                  */
                 public class IOHandlerFactory {
                          public enum IOType {
                           MEMORY, DISK, OTHER
                            }
                          public static IOHandlerService createIOHandler(IOType ioType) {
                                   switch (ioType) {
                                   case MEMORY:
                                        return new MemoryIOHandlerImpl();
                                   case DISK:
                                        return new DiskIOHandlerImpl();
                                   case OTHER:
                                        return null;
                                   default:
                                        return null;
                                   }
                             }
                 }
                  public static void main(String[] args) {
                    //通过IOHandlerFactory工厂类，传入不同的缓存名称，比如MEMORY、DISK，就可以切换对应的缓存方式
                    IOHandlerService iOHandlerService = IOHandlerFactory.createIOHandler(IOHandlerFactory.IOType.MEMORY);
                    iOHandlerService.save("name", "小雨");
                    iOHandlerService.save("age", "28");
                    String name = iOHandlerService.getString("name");
                    String age = iOHandlerService.getString("age");
                    System.out.println("name = " + name + " , age = " + age);
                   }
* 优点：解耦
* 缺点：如果新增一种缓存方式，需要改动原来的代码。
##### 工厂方法模式：
描述：接口(IOHandler)里面定义两种缓存方式：内存缓存、磁盘缓存，分别对应两个实现类，一个工厂接口，两个工厂实现类（内存缓存、磁盘缓存）。如下：

            // @Description: ? 表示通配符类型<? extends T> 既然是extends，就是表示泛型参数类型的上界，
                     说明参数的类型应该是T或者T的子类。<? super T> 既然是super，表示的则是类型的下界，
                     说明参数的类型应该是T类型的父类，一直到object。
            //工厂类接口
            public interface IOHandlerFactoryService {
                      IOHandlerService createIOHandler();
                     }
            //内存缓存工厂类
            public class MemoryIOHandlerFactory implements IOHandlerFactoryService {
                      @Override
                      public IOHandlerService createIOHandler() {
                            return new MemoryIOHandlerImpl();
                      }
              }
            //磁盘缓存工厂类
            public class DiskIOHandlerFactory implements IOHandlerFactoryService {
                      @Override
                      public IOHandlerService createIOHandler() {
                             return new DiskIOHandlerImpl();
                      }
              }
            public static void main(String[] args) {
                //通过IOHandlerFactory工厂类，传入不同的缓存名称，比如MEMORY、DISK，就可以切换对应的缓存方式
            //		IOHandlerService iOHandlerService = IOHandlerFactory.createIOHandler(IOHandlerFactory.IOType.MEMORY);
            //		iOHandlerService.save("name", "小雨");
            //		iOHandlerService.save("age", "28");
            //		String name = iOHandlerService.getString("name");
            //		String age = iOHandlerService.getString("age");
            //		System.out.println("name = " + name + " , age = " + age);
            //		
                    IOHandlerFactoryService ioHandlerFactoryService = new MemoryIOHandlerFactory();
                    IOHandlerService handlerService = ioHandlerFactoryService.createIOHandler();
                    handlerService.save("test", 1);
              }
* 优点：假如要新增一种缓存方式，直接新增两个类，一个工厂类一个实现类就可以，不需要修改原来的代码逻辑；
* 缺点：每新增一种缓存方式，类会不断增加，而且逻辑基本一样，在一定程度上，代码冗余；

##### 抽象工厂模式：

            public interface IOHandlerFactoryService {
                    IOHandlerService createIOHandler(Class<? extends IOHandlerService> ioHandlerClass);
            }
            public class IOHandlerObstractFactory implements IOHandlerFactoryService {
                      private static volatile IOHandlerObstractFactory instance;
                      private IOHandlerService mMemoryIOHandler;
                      private IOHandlerObstractFactory() {
                      }
                      public static IOHandlerObstractFactory getInstance() {
                                if (instance == null) {
                                  synchronized (IOHandlerObstractFactory.class) {
                                    if (instance == null) {
                                      instance = new IOHandlerObstractFactory();
                                    }
                                  }
                                }
                                return instance;
                      }
                      @Override
                      public IOHandlerService createIOHandler() {
                                return null;
                      }
                      @Override
                      public IOHandlerService createIOHandler(Class<? extends IOHandlerService> ioHandlerClass) {
                                try {
                                  return ioHandlerClass.newInstance();
                                } catch (Exception e) {
                                  e.printStackTrace();
                                }
                                return null;
                      }

                      /**
                       * 获取 运行内存 存储
                       */
                      public IOHandlerService getMemoryIOHandler() {
                                if (mMemoryIOHandler == null) {
                                  mMemoryIOHandler = createIOHandler(MemoryIOHandlerImpl.class);
                                }
                                return mMemoryIOHandler;
                      }
                      /**
                       * 获取 磁盘 存储
                       */
                      public IOHandlerService getDiskIOHandler() {
                                return createIOHandler(DiskIOHandlerImpl.class);
                        }
                     }
            public static void main(String[] args) {
                    IOHandlerService ioHandler = IOHandlerObstractFactory.getInstance().getDiskIOHandler();
                    ioHandler.save("name" , "test");
                    ioHandler.save("age" , "test");
                    //工厂设计模式就是专门生产对象的，把对象的实例化和初始化都封装起来,达到解耦的目的。
              }
