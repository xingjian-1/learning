#### 场景
大数据公司，提供了一个数据查询平台供用户查询信息，平台内容面很广，数据量也很多，随着后期用户越来越多，平台所承受的数据读写压力变大，内容访问速度随之变慢，为了解决这个问题决定采取缓存服务，把一些频繁访问的内容放到缓存里面，来提高用户的访问速度.就选了一家专门做缓存服务的供应商，这家供应商提供了：CDN缓存、反向代理缓存、本地缓存（磁盘缓存、内存缓存）三种缓存服务。
##### 简单工厂模式
供应商在软件开发里面设计接口可能是这样的：<br>
* 接口:有哪些操作、怎么操作需要有一个统一的规范（缓存数据的添加、缓存数据的获取，需要传什么样的参数、返回哪些数据等等)，这些都定义在接口里面。
* 实现类：一个接口对应一个实现类。
这样的设计随着后期缓存实现方式的增加和逻辑的不断迭代更新，会发现程序代码耦合度高、复用性差，不容易维护等问题。<br>
描述:接口(IOHandler)定义两个缓存方式：内存缓存、磁盘缓存,分别对应两个实现类，创建一个工厂类，定义一个方法返回不同的实现方式。如下：

                 public interface IOHandlerService {
                          void save(String key, String value);
                          String getString(String key);
                 }
                 //内存缓存实现
                 public class MemoryIOHandlerImpl implements IOHandlerService {
                          @Override
                          public void save(String key, String value) {
                                System.out.println(key + "" + value);
                          }
                          @Override
                          public String getString(String key) {
                                return null;
                          }
                 }
                 //磁盘缓存实现
                 public class DiskIOHandlerImpl implements IOHandlerService{
                          @Override
                          public void save(String key, String value) {
                          }      
                          @Override
                          public String getString(String key) {
                                return null;
                          }
                 }
                 /**
                  * @Description工厂类
                  */
                 public class IOHandlerFactory {
                          public enum IOType {
                           MEMORY, DISK, OTHER
                            }
                          public static IOHandlerService createIOHandler(IOType ioType) {
                                   switch (ioType) {
                                   case MEMORY:
                                        return new MemoryIOHandlerImpl();
                                   case DISK:
                                        return new DiskIOHandlerImpl();
                                   case OTHER:
                                        return null;
                                   default:
                                        return null;
                                   }
                             }
                 }
                  public static void main(String[] args) {
                    //通过IOHandlerFactory工厂类，传入不同的缓存名称，比如MEMORY、DISK，就可以切换对应的缓存方式
                    IOHandlerService iOHandlerService = IOHandlerFactory.createIOHandler(IOHandlerFactory.IOType.MEMORY);
                    iOHandlerService.save("name", "小雨");
                    iOHandlerService.save("age", "28");
                    String name = iOHandlerService.getString("name");
                    String age = iOHandlerService.getString("age");
                    System.out.println("name = " + name + " , age = " + age);
                   }
这里的工厂类代表供应商，我们只需要知道有哪些缓存方式，直接拿来用就可以了，不关注那些缓存方式具体如何实现。这里的供应商和缓存方式都是固定的，如果供应商不固定怎么办呢？试试工厂方法模式
* 优点：解耦
* 缺点：如果新增一种缓存方式，需要改动原来的代码。
##### 工厂方法模式：
经过一段时间的市场调研，发现另外一家供应商的反向代理缓存服务价格更低，性能更好，而这家的本地缓存稳定性要好于那家,两个都用，用相对最好服务<br>
描述：接口(IOHandler)定义两种缓存方式：内存缓存、磁盘缓存、反向代理缓存，分别对应三个实现类，一个工厂接口，三个工厂实现类（内存缓存、磁盘缓存、反向代理缓存）。如下：

           
            //工厂类接口
            public interface IOHandlerFactoryService {
                      IOHandlerService createIOHandler();
                     }
            //内存缓存工厂类
            public class MemoryIOHandlerFactory implements IOHandlerFactoryService {
                      @Override
                      public IOHandlerService createIOHandler() {
                            return new MemoryIOHandlerImpl();
                      }
              }
            //磁盘缓存工厂类
            public class DiskIOHandlerFactory implements IOHandlerFactoryService {
                      @Override
                      public IOHandlerService createIOHandler() {
                             return new DiskIOHandlerImpl();
                      }
              }
            //反向代理缓存工厂类
            public class ProxyIOHandlerFactory implements IOHandlerFactoryService {
                      @Override
                      public IOHandlerService createIOHandler() {
                             return new ProxyIOHandlerImpl();
                      }
              }
            public static void main(String[] args) {
                //通过IOHandlerFactory工厂类，传入不同的缓存名称，比如MEMORY、DISK，就可以切换对应的缓存方式
            //		IOHandlerService iOHandlerService = IOHandlerFactory.createIOHandler(IOHandlerFactory.IOType.MEMORY);
            //		iOHandlerService.save("name", "小雨");
            //		iOHandlerService.save("age", "28");
            //		String name = iOHandlerService.getString("name");
            //		String age = iOHandlerService.getString("age");
            //		System.out.println("name = " + name + " , age = " + age);
            //		
                    IOHandlerFactoryService ioHandlerFactoryService = new MemoryIOHandlerFactory();
                    IOHandlerService handlerService = ioHandlerFactoryService.createIOHandler();
                    handlerService.save("test", 1);
              }
* 优点：假如要新增一种缓存方式，直接新增两个类，一个工厂类一个实现类就可以，不需要修改原来的代码逻辑；
* 缺点：每新增一种缓存方式，类会不断增加，而且逻辑基本一样，在一定程度上，代码冗余；
工厂方法模式：缓存方式服务是固定的，供应商不固定，如果提供的缓存方式这种服务也不固定呢？
##### 抽象工厂模式：
            
            public interface IOHandlerFactoryService {
                    IOHandlerService createIOHandler(Class<? extends IOHandlerService> ioHandlerClass);
            }
            public interface AbstractFactory {
            //创建Html文档:
            HtmlDocument createHtml(String md);
            }
            // @Description: ? 表示通配符类型<? extends T> 既然是extends，就是表示泛型参数类型的上界，
                     说明参数的类型应该是T或者T的子类。<? super T> 既然是super，表示的则是类型的下界，
                     说明参数的类型应该是T类型的父类，一直到object。
            public class IOHandlerObstractFactory implements IOHandlerFactoryService {
                      private static volatile IOHandlerObstractFactory instance;
                      private IOHandlerService mMemoryIOHandler;
                      private IOHandlerObstractFactory() {
                      }
                      public static IOHandlerObstractFactory getInstance() {
                                if (instance == null) {
                                  synchronized (IOHandlerObstractFactory.class) {
                                    if (instance == null) {
                                      instance = new IOHandlerObstractFactory();
                                    }
                                  }
                                }
                                return instance;
                      }
                      @Override
                      public IOHandlerService createIOHandler() {
                                return null;
                      }
                      @Override
                      public IOHandlerService createIOHandler(Class<? extends IOHandlerService> ioHandlerClass) {
                                try {
                                  return ioHandlerClass.newInstance();
                                } catch (Exception e) {
                                  e.printStackTrace();
                                }
                                return null;
                      }

                      /**
                       * 获取 运行内存 存储
                       */
                      public IOHandlerService getMemoryIOHandler() {
                                if (mMemoryIOHandler == null) {
                                  mMemoryIOHandler = createIOHandler(MemoryIOHandlerImpl.class);
                                }
                                return mMemoryIOHandler;
                      }
                      /**
                       * 获取 磁盘 存储
                       */
                      public IOHandlerService getDiskIOHandler() {
                                return createIOHandler(DiskIOHandlerImpl.class);
                        }
                     }
            public static void main(String[] args) {
                    IOHandlerService ioHandler = IOHandlerObstractFactory.getInstance().getDiskIOHandler();
                    ioHandler.save("name" , "test");
                    ioHandler.save("age" , "test");
                    //工厂设计模式就是专门生产对象的，把对象的实例化和初始化都封装起来,达到解耦的目的。
              }
