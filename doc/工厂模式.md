#### 简单工厂模式
比如有一批数据需要作缓存处理，提供了两种实现方式分别为内存缓存实现和磁盘缓存实现。具体提供了哪些操作、怎么操作在接口里面需要作一个统一的规范，例如缓存数据的添加、缓存数据的获取，需要传什么样的参数、返回哪些数据等等一些公共的东西。
一个接口(IOHandler)里面定义了三种不同的缓存方式分别为：内存缓存、磁盘缓存、本地缓存。分别对应三种实现，工厂类定义一个方法返回不同的实现方式对象。
优点：解耦
缺点：如果新增一种缓存方式，需要改动原来的代码。
                 public interface IOHandlerService {
                  void save(String key, String value);
                  void save(String key, double value);
                  void save(String key, int value);
                  void save(String key, long value);
                  void save(String key, boolean value);
                  void save(String key, Object value);
                  String getString(String key);
                  double getDouble(String key, double defaultValue);
                  int getInt(String key, int defaultValue);
                  long getLong(String key, long defaultValue);
                  boolean getBoolean(String key, boolean defaultValue);
                  Object getObject(String key);
                 }
                 /**
                  * @Description 内存缓存实现
                  */
                 public class MemoryIOHandlerImpl implements IOHandlerService {

                  @Override
                  public void save(String key, String value) {
                   System.out.println(key + "" + value);
                  }
                  @Override
                  public void save(String key, double value) {
                  }
                  @Override
                  public void save(String key, int value) {
                   System.out.println(key + "-" + value);
                  }
                  @Override
                  public void save(String key, long value) {
                  }
                  @Override
                  public void save(String key, boolean value) {
                  }
                  @Override
                  public void save(String key, Object value) {
                  }
                  @Override
                  public String getString(String key) {
                   return null;
                  }
                  @Override
                  public double getDouble(String key, double defaultValue) {
                   return 0;
                  }
                  @Override
                  public int getInt(String key, int defaultValue) {
                   return 0;
                  }
                  @Override
                  public long getLong(String key, long defaultValue) {
                   return 0;
                  }
                  @Override
                  public boolean getBoolean(String key, boolean defaultValue) {
                   return false;
                  }
                  @Override
                  public Object getObject(String key) {
                   return null;
                  }
                 }
                 /**
                  * @Description 磁盘缓存实现
                  */
                 public class DiskIOHandlerImpl implements IOHandlerService{
                  @Override
                  public void save(String key, String value) {
                  }
                  @Override
                  public void save(String key, double value) {
                  }
                  @Override
                  public void save(String key, int value) {
                  }
                  @Override
                  public void save(String key, long value) {
                  }
                  @Override
                  public void save(String key, boolean value) {
                  }
                  @Override
                  public void save(String key, Object value) {
                  }
                  @Override
                  public String getString(String key) {
                   return null;
                  }
                  @Override
                  public double getDouble(String key, double defaultValue) {
                   return 0;
                  }
                  @Override
                  public int getInt(String key, int defaultValue) {
                   return 0;
                  }
                  @Override
                  public long getLong(String key, long defaultValue) {
                   return 0;
                  }
                  @Override
                  public boolean getBoolean(String key, boolean defaultValue) {
                   return false;
                  }
                  @Override
                  public Object getObject(String key) {
                   return null;
                  }
                 }
                 /**
                  * @Description工厂类
                  */
                 public class IOHandlerFactory {
                  public enum IOType {
                   MEMORY, DISK, OTHER
                  }

                  public static IOHandlerService createIOHandler(IOType ioType) {
                   switch (ioType) {
                   case MEMORY:
                    return new MemoryIOHandlerImpl();
                   case DISK:
                    return new DiskIOHandlerImpl();
                   case OTHER:
                    return null;
                   default:
                    return null;
                   }
                  }
                 }
                  public static void main(String[] args) {
                    //通过IOHandlerFactory工厂类，传入不同的缓存名称，比如MEMORY、DISK，就可以切换对应的缓存方式
                    IOHandlerService iOHandlerService = IOHandlerFactory.createIOHandler(IOHandlerFactory.IOType.MEMORY);
                    iOHandlerService.save("name", "小雨");
                    iOHandlerService.save("age", "28");
                    String name = iOHandlerService.getString("name");
                    String age = iOHandlerService.getString("age");
                    System.out.println("name = " + name + " , age = " + age);
                   }
 优点：

    用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
    灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
    典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

缺点：

    类的个数容易过多，增加复杂度
    增加了系统的抽象性和理解难度
    抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。

应用场景：

    客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。
    创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
    客户不关心创建产品的细节，只关心产品的品牌
工厂方法模式的主要角色如下。

    抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
    具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
    抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
    具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。
