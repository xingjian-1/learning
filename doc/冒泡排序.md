#### 冒泡排序
* 1、比较相邻的两个元素如果第一个比第二个大，就交换它们的位置。
* 2、然后第二个与第三个对比，对每一对相邻元素作同样的工作，这样在最后的元素应该会是最大的数。
* 3、针对所有的元素重复以上的步骤，除了最后一个。
* 4、重复步骤1~3，直到排序完成。 <br> <img src="/img/20200813152514.jpg" width="40%" hight="30%">
##### 示例

        int a[] = {6, 3, 4, 2, 10, 1 ,8,5,9};
        for (int i = 0; i<a.length-1; i++) {
            for (int j = 0; j<a.length-1-i; j++) {
              if (a[j] > a[j + 1]) {
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
              }
            }
       }
##### 优缺点 
优点：实现和理解简单。缺点：时间复杂度是O(n^2)，排序元素多时效率比较低。
##### 适用范围
数据已经基本有序，且数据量较小的场景。
##### 场景优化 
* （1）部分已经有序了，下一轮的时候但还是会被遍历：记录有序和无序数据的边界，有序的部分在下一轮就不用遍历了。
* （2）在每趟扫描中，记住最后一次交换发生的位置lastExchange，（该位置之后的相邻记录均已有序）。下一趟排序开始时，R[1..lastExchange-1]是无序区，R[lastExchange..n]是有序区。这样，一趟排序可能使当前无序区扩充多个记录，因此记住最后一次交换发生的位置lastExchange，从而减少排序的趟数

                在每趟排序开始前，先将其置为0。若排序过程中发生了交换，则将其置为1。各趟排序结束时检查flag，若未曾发生过交换则终止算法，不再进行下一趟排序。
                  int flag = 0;
                  for (int i = 0; i<a.length-1; i++) {
                    for (int j = 0; j<a.length-1-i; j++) {
                      if (a[j] > a[j + 1]) {
                        int temp = a[j];
                        a[j] = a[j + 1];
                        a[j + 1] = temp;
                        flag = 1;//只要有发生了交换，flag就置为1
                      }
                    }
                   //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return
                  if (flag == 0){
                   return;
                  }
               }
                  
