#### 冒泡排序
比较相邻的元素：
* 1、如果第一个比第二个大，就交换它们两个。
* 2、然后第二个与第三个对比，对每一对相邻元素作同样的工作，这样在最后的元素应该会是最大的数。
* 3、针对所有的元素重复以上的步骤，除了最后一个。
* 4、重复步骤1~3，直到排序完成。 <br><img src="/img/20200813152514.jpg" width="40%" hight="30%">
##### 示例

        int a[] = {6, 3, 4, 2, 10, 1 ,8,5,9};
        for (int i = 0; i<a.length-1; i++) {
            for (int j = 0; j<a.length-1-i; j++) {
              if (a[j] > a[j + 1]) {
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
              }
            }
       }
##### 优缺点 
优点：实现和理解简单。缺点：时间复杂度是O(n^2)，排序元素多时效率比较低。
##### 适用范围
数据已经基本有序，且数据量较小的场景。
##### 场景优化 
* （1）已经有序了还再继续冒泡问题本轮排序中，元素没有交换，则isSorted为true，直接跳出大循环，避免后续无意义的重复。
* （2）部分已经有序了，下一轮的时候但还是会被遍历：记录有序和无序数据的边界，有序的部分在下一轮就不用遍历了。
* （3）只有一个元素不对，但需要走完全部轮排序：鸡尾酒排序：元素的比较和交换是双向的，就像摇晃鸡尾酒一样
