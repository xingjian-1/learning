#### 快速排序
从数列中挑出一个元素，称为基准值（pivot）。排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。递归地对【小于基准值元素的子数列】和【大于基准值元素的子数列】进行排序。
##### 基本思想
* 先从数组中找一个基准数，比如就拿数组的第一个数为基准数。
* 把其他比它大的元素移动到数列一边，比他小的元素移动到数列另一边，从而把数组拆解成两个部分。
* 对左右区间重复第二步，直到各区间只有一个数。<br> <img src="/img/20200813163853.png" width="30%" hight="30%">
##### 优缺点
优点：性能较好，时间复杂度最好为O(nlogn)，大多数场景性能都接近最优。原地排序，时间复杂度优于归并排序。缺点：部分场景，排序性能最差为O(n^2)。不稳定排序。
##### 适用范围
大数据量且不要求排序稳定的场景。
##### 场景优化
* （1）每次的基准元素都选中最大或最小元素随机选择基准元素，而不是选择第一个元素。三数取中法，随机选择三个数，取中间数为基准元素。
* （2）数列含有大量重复数据大于、小于、等于基准值。
* （3）快排的性能优化双轴快排：2个基准数，例子：Arrays.sort() 。
##### 代码示例

                   public int[] sortArray(int[] nums) {
                      quickSort(nums,0,nums.length-1);
                      return nums;
                  }
                  public void quickSort (int[] nums, int low, int hight) {
                      if (low < hight) {
                          int index = partition(nums,low,hight);
                          quickSort(nums,low,index-1);
                          quickSort(nums,index+1,hight);
                      }
                  }
                  public int partition (int[] nums, int low, int hight) {
                      int pivot = nums[low];
                      while (low < hight) {
                          //移动hight指针
                          while (low < hight && nums[hight] >= pivot ) {
                              hight--;
                          }
                          //填坑
                          if (low < hight) nums[low] = nums[hight];
                          while (low < hight && nums[low] <= pivot) {
                              low++;
                          }
                          //填坑
                          if (low < hight) nums[hight] = nums[low];
                      }
                      //基准数放到合适的位置
                      nums[low] = pivot;
                      return low;
                  }
##### if后面加与不加{}问题

                  1.不加{}
                  if (1==2)
                  x=1;y=2;z=3;
                  编译后
                  if (1==2)
                  {x=1};y=2;z=3; 
                  所以当1!=2时，y=2;z=3;仍执行。

                  2.加{}
                  if (1 == 2)
                  { x=1;y=2;z=3;}
                  所以当1！=2时，都不执行。
                  通俗理解:后面不加{}时，就近原则，只控制第一句
