#### 原型(Prototype)模式
原型模式（Prototype Pattern）用于创建重复的对象，同时又能保证性能,属于创建型模式，它提供了一种创建对象的最佳方式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
##### 浅拷贝（ShallowClone）
		浅拷贝：当对象被复制时，只复制对象本身与基本数据类型（8种）的成员变量，引用类型的成员变量没有被复制，只是拷贝了
		d源对象的地址，源对象的值发生改变时，拷贝的对象也会变。
		对于集合、引用对象等都不会拷贝,当类的成员变量是基本数据类型时，浅拷贝会复制该属性的值赋值给新对象。当成员变量是引用数据类型时，浅拷贝复制的是引用数据类型的地址值。
		这种情况下，当拷贝出的某一个类修改了引用数据类型的成员变量后，会导致所有拷贝出的类都发生改变。
		/**
		 * @Description 原型模式-浅拷贝 write by xj on date 2021/2/7
		 */
		public class Prototype implements Cloneable {
			private Integer id;
			private String merCd;
			private String merName;
			private Map<String, String> map;
			//setter and getter
			@Override
			public Object clone() throws CloneNotSupportedException { // 浅克隆
				Prototype prototype = (Prototype) super.clone();
				return prototype;
			}
			// 测试类
			public static void main(String[] args) throws CloneNotSupportedException {
				Prototype prototype = new Prototype();
				prototype.setMerCd("shallow");
				Prototype shallowClone = (Prototype) prototype.clone();
				System.out.println("prototype:" + prototype);
				System.out.println("shallowClone: " + shallowClone);
			}
##### 深拷贝
		当对象被复制时，对象本身、值类型成员变量、引用类型成员变量都会被复制，原型对象与复制对象完全独立。修改一个对象的数据不会对另外一个对象造成影响。
		//深拷贝如果用流的方式实现需要实现序列化的接口。
		public class Computer implements Cloneable, Serializable {
			private static final long serialVersionUID = 1L;
			private String name;			
			@Override
			protected Object clone() throws CloneNotSupportedException {
				return super.clone();
			}
		  }
		/**
		 * @Description 原型模式 write by xj on date 2021/2/7
		 */
		public class Prototype implements Cloneable,Serializable {
			private Integer id;
			private String merCd;
			private String merName;
			private Map<String, String> map;
			private Computer computer;
			//setter and getter
			@Override
			public Object clone() throws CloneNotSupportedException {
				Prototype prototype = (Prototype) super.clone();
				prototype.computer = (Computer) this.computer.clone();
				return prototype;
			}
			public Prototype deepClone() {
				// 声明流对象
				ByteArrayOutputStream bos = null;
				ByteArrayInputStream bis = null;
				ObjectOutputStream oos = null;
				ObjectInputStream ois = null;
				try{
					// 创建序列化流
					bos = new ByteArrayOutputStream();
					oos = new ObjectOutputStream(bos);
					// 将当前对象以对象流的方式输出
					oos.writeObject(this);

					// 创建反序列化流
					bis = new ByteArrayInputStream(bos.toByteArray());
					ois = new ObjectInputStream(bis);
					// 将流对象反序列化，实现类的深拷贝
					return (Prototype) ois.readObject();
				}catch (Exception e) {
					return null;
				}finally {
					try {
						bos.close();
						bis.close();
						oos.close();
						ois.close();
					} catch (Exception e2) {
						e2.printStackTrace();
					}
				}  
			   }

			// 测试类
			public static void main(String[] args) throws CloneNotSupportedException {
					// 深拷贝1
					Prototype prototype = new Prototype();
					Computer c = new Computer();
					c.setName("盖聂");
					prototype.setComputer(c);
					prototype.setMerCd("shallow");
					Prototype shallowClone = (Prototype) prototype.clone();
					// 序列化对象实现深拷贝2
					Prototype deepClone = (Prototype) prototype.deepClone();
					System.out.println("prototype:" + prototype);
					System.out.println("deepClone: " + deepClone);
					}
			}                                                                                                        
