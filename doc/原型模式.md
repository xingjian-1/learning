#### 原型(Prototype)模式
如果系统中需要大量创建相同或者相似的对象时，可以通过原型设计模式来实现,分为两种
##### 浅拷贝
		只拷贝对象中的基本数据类型（8种），对于数组、容器、引用对象等都不会拷贝,当类的成员变量是基本数据类型时，
		浅拷贝会复制该属性的值赋值给新对象。当成员变量是引用数据类型时，浅拷贝复制的是引用数据类型的地址值。
		这种情况下，当拷贝出的某一个类修改了引用数据类型的成员变量后，会导致所有拷贝出的类都发生改变。
		/**
		 * @Description 原型模式-浅拷贝 write by xj on date 2021/2/7
		 */
		public class Prototype implements Cloneable {
			private Integer id;
			private String merCd;
			private String merName;
			private Map<String, String> map;
			public Integer getId() {
				return id;
				}
			public void setId(Integer id) {
				this.id = id;
				}
			public String getMerCd() {
				return merCd;
				}
			public void setMerCd(String merCd) {
				this.merCd = merCd;
				}
			public String getMerName() {
				return merName;
				}
			public void setMerName(String merName) {
				this.merName = merName;
				}
			public Map<String, String> getMap() {
				return map;
				}
			public void setMap(Map<String, String> map) {
				this.map = map;
				}
			// 方便测试时打印类的属性
			public String toString() {
				return "Prototype [id=" + id + ", merCd=" + merCd + ",
				merName=" + merName + ", map=" + map + "]";
				}

			@Override
			public Object clone() throws CloneNotSupportedException { // 浅克隆
				Prototype prototype = (Prototype) super.clone();
				return prototype;
				}
			// 测试类
			public static void main(String[] args) throws CloneNotSupportedException {
				Prototype prototype = new Prototype();
				prototype.setMerCd("shallow");
				Prototype shallowClone = (Prototype) prototype.clone();
				System.out.println("prototype:" + prototype);
				System.out.println("shallowClone: " + shallowClone);
				}
##### 深拷贝
		不仅能拷贝基本数据类型，还能拷贝那些数组、容器、引用对象等，深拷贝不仅会复制成员变量为基本数据类型的值，
		给新对象。还会给引用类型的成员变量申请储存空间，并复制引用数据类型成员变量的对象。
		这样拷贝出的新对象修改了是引用数据类型的成员变量后，不会对其它拷贝出的对象造成影响,
		深拷贝如果用流的方式实现需要实现序列化的接口。
		public class Computer implements Cloneable, Serializable {
			private static final long serialVersionUID = 1L;
			private String name;
			public String getName() {
				return name;
				}
			public void setName(String name) {
				this.name = name;
			 	}
			@Override
			public String toString() {
				return "Computer [name=" + name + ", getName()=" + getName() + ", 
				getClass()=" + getClass() + ", hashCode()="
				+ hashCode() + ", toString()=" + super.toString() + "]";
				}
			@Override
			protected Object clone() throws CloneNotSupportedException {
				return super.clone();
				}
			 }
		/**
		 * @Description 原型模式 write by xj on date 2021/2/7
		 */
		public class Prototype implements Cloneable,Serializable {
			private Integer id;
			private String merCd;
			private String merName;
			private Map<String, String> map;
			private Computer computer;
			public Integer getId() {
				return id;
				}
			public void setId(Integer id) {
				this.id = id;
				}
			public String getMerCd() {
				return merCd;
				}
			public void setMerCd(String merCd) {
				this.merCd = merCd;
				}
			public String getMerName() {
				return merName;
				}
			public void setMerName(String merName) {
				this.merName = merName;
				}
			public Map<String, String> getMap() {
				return map;
				}
			public void setMap(Map<String, String> map) {
				this.map = map;
				}
			public Computer getComputer() {
				return computer;
				}
			public void setComputer(Computer computer) {
				this.computer = computer;
				}
			// 方便测试时打印类的属性
			@Override
			public String toString() {
				return "Prototype [id=" + id + ", merCd=" + merCd + ", merName=" + merName +
				", map=" + map + ", computer="+ computer + ", getId()=" + getId() + ", 
				getMerCd()=" + getMerCd() + ", getMerName()=" + getMerName()+ ", getMap()=" + getMap() + 
				", getComputer()=" + getComputer() + ", getClass()=" + getClass()+ ", hashCode()=" + 
				hashCode() + ", toString()=" + super.toString() + "]";
				}
			@Override
			public Object clone() throws CloneNotSupportedException {
				Prototype prototype = (Prototype) super.clone();
				prototype.computer = (Computer) this.computer.clone();
				return prototype;
				}
			public Prototype deepClone() {
				// 声明流对象
				ByteArrayOutputStream bos = null;
				ByteArrayInputStream bis = null;
				ObjectOutputStream oos = null;
				ObjectInputStream ois = null;
				try{
					// 创建序列化流
					bos = new ByteArrayOutputStream();
					oos = new ObjectOutputStream(bos);
					// 将当前对象以对象流的方式输出
					oos.writeObject(this);

					// 创建反序列化流
					bis = new ByteArrayInputStream(bos.toByteArray());
					ois = new ObjectInputStream(bis);
					// 将流对象反序列化，实现类的深拷贝
					return (Prototype) ois.readObject();
				}catch (Exception e) {
					return null;
				}finally {
					try {
						bos.close();
						bis.close();
						oos.close();
						ois.close();
					} catch (Exception e2) {
						e2.printStackTrace();
					}
				}  
			   }

			// 测试类
			public static void main(String[] args) throws CloneNotSupportedException {
					// 深拷贝1
					Prototype prototype = new Prototype();
					Computer c = new Computer();
					c.setName("盖聂");
					prototype.setComputer(c);
					prototype.setMerCd("shallow");
					Prototype shallowClone = (Prototype) prototype.clone();
					// 序列化对象实现深拷贝2
					Prototype deepClone = (Prototype) prototype.deepClone();
					System.out.println("prototype:" + prototype);
					System.out.println("deepClone: " + deepClone);
					}
				}                                                                                                        
