#### synchronized锁升级过程
锁的级别从低到高：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁<br>
锁分级别原因：没有优化以前，sychronized是重量级锁（悲观锁），使用 wait 和 notify、notifyAll 来切换线程状态非常消耗系统资源；线程的挂起和唤醒间隔很短暂，这样很浪费资源，影响性能。所以 JVM 对 sychronized 关键字进行了优化，把锁分为 无锁、偏向锁、轻量级锁、重量级锁 状态。
##### 无锁
没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，其他修改失败的线程会不断重试直到修改成功。
##### 偏向锁
一个程序一直被同一线程执行，不存在多个线程竞争，该线程在后续的执行中自动获取锁，降低获取锁带来的性能开销。偏向锁，指的就是偏向第一个加锁线程，该线程是不会主动释放偏向锁的，只有当其他线程尝试竞争偏向锁才会被释放。
偏向锁的撤销，需要在某个时间点上没有字节码正在执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁；如果线程处于活动状态，升级为轻量级锁的状态。
##### 轻量级锁
轻量级锁是指当锁是偏向锁的时候，被第二个线程 B 所访问，此时偏向锁就会升级为轻量级锁，线程B会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。
当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁；当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁。
##### 重量级锁
指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。
##### CAS操作
在Java多线程中，乐观锁一个常见实现是CAS操作。

          CAS操作过程：
          V：当前内存地址实际存放的值；
          O：内存存放预期值（旧值）；
          N :更新的新值。
          当V=0，预期值和内存实际值相等，内存存放的实际值没有被任何其他线程修改，即O就是目前最新的值，可以将新值N赋给V；
          当V！=O，表明内存存放的实际值已经被其他线程修改，因此O值不是当前最新值，返回V，无法修改。（将V返回是因为再次重试时期待值就变为V）
##### CAS存在问题
* ABA问题
比如一个线程1从内存位置V取出A，这时候另一个线程2也从内存中取出A，并且线程2进行了一些操作变成B，然后线程2又将内存位置V的数据变为A，这时候线程1进行CAS操作发现内存中仍然是A，然后线程1操作成功。尽管线程1的CAS操作成功，但是并不代表这个过程没有问题。如果链表的头在变化了2次后恢复了原值，但是并不代表链表没有变化。
对于ABA问题解决办法是添加一个版本号，对上述例子是将2个A进行不同的标记比如A1,A2等，由于版本号不同，线程1无法操作成功。在JDK1.5之后使用atomic包中提供的AtomicStampedReference 类来解决。
* 自旋会浪费大量的CPU资源
与阻塞线程相比，自旋会浪费大量的处理器资源。因为当前线程仍处于运行状态，只不过跑的是无用指令。自旋线程希望在运行无用指令时，锁能够被释放出来。解决办法是：自适应自旋：根据以往自旋等待时间能否获取锁来动态调整自旋的时间（循环次数）。如果在上次自旋时获取到锁，则会稍微增加下一次自旋时间；否则即稍微减少下一次自旋时间。
##### volatile和synchronized特点
首先需要理解线程安全的两个方面：执行控制和内存可见。执行控制的目的是控制代码执行（顺序）及是否可以并发执行。内存可见控制的是线程执行结果在内存中对其它线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。<br>
synchronized关键字解决的是执行控制的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，synchronized还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都happens-before于随后获得这个锁的线程的操作。<br>
volatile关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。使用volatile关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， volatile不能保证复合操作的原子性，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。
在Java 5提供了原子数据类型atomic wrapper classes，对它们的increase之类的操作都是原子操作，不需要使用sychronized关键字。
对于volatile关键字，当且仅当满足以下所有条件时可使用：

              1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
              2. 该变量没有包含在具有其他变量的不变式中。
##### volatile和synchronized的区别
* volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
* volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
* volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
* volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
* volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
