##### 简介
Java异常是Java提供的一种识别及响应错误的一致性机制。Java的异常机制可以使程序中异常处理代码和正常业务代码相分离，保证程序代码更加优雅及健壮性。能让程序对于一些不正常的信息清晰的作出 为什么抛出、在哪抛出、抛出什么这一系列的动作。Throwable包含两个子类分别为： Error和Exception。Throwable提供了printStackTrace接口用于获取堆栈跟踪数据等信息。
##### Error(错误)
程序本身无法处理的错误，非程序本身的问题。例如：Virtual MachineError(虚拟机运行错误)、NoClassDefFoundError(类定义错误)、OutOfMemoryError(内存不足错误)、StackOverFlowError(栈溢出错误)，此类错误发生时JVM终止线程。
##### Exception(异常)
程序本身可以捕获并且可以处理的异常。分为两类：运行时异常和编译时异常。
##### RuntimeException(运行时异常)
表示JVM在运行期间可能出现的异常，由Java虚拟机自动抛出并自动捕获。Java编译器不会检查它，也就是说在类中既没有throws抛出异常，也没有try-catch捕捉异常，还是会编译通过，例如：NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界、ClassCastException类型转换异常、ArithmeticException算术异常。
##### 编译时异常
Exception中除了RuntimeException及其子类之外的异常。Java编译器会检查它，出现这类异常要么throws声明抛出、要么try-catch捕捉处理，否则不能通过编译。例如：ClassNotFundException没有找到指定的异常类、IOExceptionIO流异常等。
##### 受检异常与非受检异常
Java的所有异常可以分为受检异常(checkedException)和非受检异常(uncheckedException)。<br>
受检异常：编译器要求必须处理的异常，当编译器检查到应用中某处可能会有此类异常时，将会提示你处理此异常。要么使用try-catch捕捉处理或者Throws关键字抛出该异常，否则编译不通过。<br>
非受检异常：编译器不会进行检查并且不要求必须处理的异常。也就是说程序中出现此类异常时，即使我们没有try-catch捕捉它，也没有Throws抛出该异常，编译也会通过。该类异常包括运行时异常(RuntimeException)和错误(Error)。
##### Java异常处理
Java通过面向对象的方法进行异常处理，一旦方法抛出异常，系统会根据该异常对象找到合适的异常处理器(Exception Handler)来处理异常。每一个异常都是一个对象，是Throwable类或其子类的实例，当一个方法出现异常后便会抛出一个异常对象，该对象中包含异常信息，调用这个对象的方法便可以捕获这个异常并可以对其处理。Java的异常处理通过五个关键字来实现：try、catch、throw、throws、finally。catch中的return会等finally中的代码执行完之后，才会执行。

* OutOfMemoryError
内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。
* IOException
受检查异常，需要进行捕获。<br>
直接抛出异常：捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去,就直接抛出，在方法签名处使用throws关键字声明可能会抛出的异常。

        private static void readFile(String filePath) throws IOException {
            File file = new File(filePath);
            String result;
            BufferedReader reader = new BufferedReader(new FileReader(file));
            while((result = reader.readLine())!=null) {
                System.out.println(result);
            }
            reader.close();
        }
* FileNotFoundException(文件找不到异常)
，如果文件不存在就会抛出这种异常

        private static void readFile(String filePath) {
            try {
                // code
            } catch (FileNotFoundException e) {
                // handle FileNotFoundException
            } catch (IOException e){
                // handle IOException
            }
        }
* ClassNotFoundException(类找不到异常)
它是受检查异常，需要进行捕获。是在加载类的时候抛出的，即在类路径下不能加载指定的类。

    public static <T> Class<T> getExistingClass(ClassLoader classLoader, String className) {
      try {
         return (Class<T>) Class.forName(className, true, classLoader);
      }
      catch (ClassNotFoundException e) {
         return null;
      }
    }

* ClassCastException(类转换异常)
这是运行时异常，不需要手工捕获，将一个不是该类的实例转换成这个类就会抛出这个异常。
如将一个数字强制转换成字符串就会报这个异常：

    Object x = new Integer(0);
    System.out.println((String)x);

* NoSuchMethodException(没有这个方法异常)
是受检查异常，需要进行捕获。一般发生在反射调用方法的时候，如：

    public Method getMethod(String name, Class<?>... parameterTypes)
        throws NoSuchMethodException, SecurityException {
        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);
        Method method = getMethod0(name, parameterTypes, true);
        if (method == null) {
            throw new NoSuchMethodException(getName() + "." + name + argumentTypesToString(parameterTypes));
        }
        return method;
    }

* IndexOutOfBoundsException(索引越界异常)
当操作一个字符串或者数组的时候经常遇到的异常。
* ArithmeticException(算术异常)
发生在数字的算术运算时的异常，如一个数字除以0就会报这个错。double n = 3 / 0;

    public static Timestamp from(Instant instant) {
        try {
            Timestamp stamp = new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);
            stamp.nanos = instant.getNano();
            return stamp;
        } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(ex);
        }
    }
* SQLException
SQL异常，发生在操作数据库时的异常。
##### final、finally、finalize区别
`final`是修饰符，修饰类，此类不能被继承，修饰方法和变量，则表示此方法和此变量不能在被改变，`finally`是try-catch-finally 最后一部分，表示不论发生任何情况都会执行，finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。
