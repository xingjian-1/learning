#### 插入法排序
插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：<br><img src="/img/2020111211440000.gif" height="30%" widht="30%">

	    1.从第一个元素开始，该元素可以认为已经被排序；
	    2.取出下一个元素，在已经排序的元素序列中从后向前扫描；
	    3.如果该元素（已排序）大于新元素，将该元素移到下一位置；
	    4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
	    5.将新元素插入到该位置后；
	    6.重复步骤2~5。
##### 示例

	      // 插入排序
	      for (int i = 0; i < a.length - 1; i++) {
		for (int j = i + 1; j > 0; j--) {
		  if (a[j] < a[j - 1]) {
		    int temp = a[j];
		    a[j] = a[j - 1];
		    a[j - 1] = temp;
		  }
		}
	      }
      
	      for (int b : a) {
		   System.out.print("" + b);
		}
##### 三数取中+插入排序
插入排序在元素个数较少时效率是最高的，可以设定一个阈值，当元素个数大于阈值时使用快速排序，小于等于该阈值时则使用插入排序。我们设定阈值为 7 。

		private static final int INSERTION_SORT_MAX_LENGTH = 7;
		    public int[] sortArray(int[] nums) {      
			quickSort(nums,0,nums.length-1);
			return nums;
		    }
		    public void quickSort (int[] nums, int low, int hight) {
			    if (hight - low <= INSERTION_SORT_MAX_LENGTH) {
				insertSort(nums,low,hight);
				return;
			    }               
			    int index = partition(nums,low,hight);
			    quickSort(nums,low,index-1);
			    quickSort(nums,index+1,hight);         
		    }
		    public int partition (int[] nums, int low, int hight) {
			    //三数取中，大家也可以使用其他方法
			    int mid = low + ((hight-low) >> 1);
			    if (nums[low] > nums[hight]) swap(nums,low,hight);
			    if (nums[mid] > nums[hight]) swap(nums,mid,hight);
			    if (nums[mid] > nums[low]) swap(nums,mid,low);   
			    int pivot = nums[low];
			    int start = low;
			    while (low < hight) {
				while (low < hight && nums[hight] >= pivot) hight--;           
				while (low < hight && nums[low] <= pivot) low++;
				if (low >= hight) break;
				swap(nums, low, hight); 
			    }
			    swap(nums,start,low);
			    return low;
		    } 
		    public void insertSort (int[] nums, int low, int hight) {
			for (int i = low+1; i <= hight; ++i) {
			    int temp = nums[i];
			    int j;
			    for (j = i-1; j >= 0; --j) {
				if (temp < nums[j]) {
				    nums[j+1] = nums[j];
				    continue;
				} 
				break;
			    }
			    nums[j+1] = temp;
			}
		    } 
		    public void swap (int[] nums, int i, int j) {
			int temp = nums[i];
			nums[i] = nums[j];
			nums[j] = temp;
		    } 
