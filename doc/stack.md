#### 栈 
`[栈]`栈是一种线性数据结构，后进先出，先进后出，最早进入的元素存放位置叫做栈底，最后进入的元素存放位置叫栈顶，栈底进，栈顶出。可以比喻成 栈是一个一端封闭一端开放的中空管子，队列是两端开放的中空管子。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。效率上：入栈O(1),出栈O(1).效率上 ：写入O(1),读取O(1),扩容O(n)。`如何实现栈？`<br><img src="/img/栈.jpg" width = "50%" height = "30%" alt="图片名称" align=center />
#### 栈的原理
`栈`存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法<br>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。栈是允许在同一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。栈也称为先进后出表。栈可以用来在函数调用的时候存储断点，做递归时要用到栈！在计算机系统中，栈则是一个动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。在i386机器中，栈顶由称为esp的寄存器进行定位。压栈的操作使得栈顶的地址减小，弹出的操作使得栈顶的地址增大。栈在程序的运行中有着举足轻重的作用。最重要的是栈保存了一个函数调用时所需要的维护信息，这常常称之为堆栈帧或者活动记录。堆栈帧一般包含如下几方面的信息：
* 函数的返回地址和参数
* 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。<br><img src="/img/2020082322580000.jpg" width=“50%” hight="50%">
#### 栈的基本算法
##### 进栈（PUSH）算法
      例如：有一个数列（23，45，3，7，3，945）
      我们先对其进行进栈操作，则进栈顺序为：23，45，3，7，3，945
      我们在对其进行出栈操作，则出栈顺序为：945，3，7，3，45，23
      算法思想：
      括号作用域检查的原则是，对表达式从左到右扫描。当遇到左括号时，左括号入栈；当遇到右括号时，首先将栈顶元素弹出栈，
      再比较弹出元素是否与右括号匹配，若匹配，则操作继续；否则，查出错误，并停止操作。当表达式全部扫描完毕，若栈为空，
      说明括号作用域嵌套正确，反之，说明表达式有错误。
##### 举例 
问题：假设有n件质量分别为w1，w2，...，wn的物品和一个最多能装载总质量为T的背包，能否从这n件物品中选择若干件物品装入背包，使得被选物品的总质量恰好等于背包所能装载的最大质量，即wi1+wi2+...+wik=T。<br>
`算法思想`：首先将n件物品排成一列，依次选取；若装入某件物品后，背包内物品的总质量不超过背包最大装载质量时，则装入（进栈）；否则放弃这件物品的选择，选择下一件物品试探，直至装入的物品总和正好是背包的最大转载质量为止。这时我们称背包装满。若装入若干物品的背包没有满，而且又无其他物品可以选入背包，说明已装入背包的物品中有不合格者，需从背包中取出最后装入的物品（退栈），然后在未装入的物品中挑选，重复此过程，直至装满背包（有解），或无物品可选（无解）为止。<br>
`具体实现`：设用数组weight[1..N]，stack[1,N]分别存放物品重量和已经装入背包（栈）的物品序号，MaxW表示背包的最大装载量。每进栈一个物品，就从MaxW中减去该物品的质量,设i为待选物品序号,若MaxW-weight[i]>=0，则该物品可选；若MaxW-weight[i] < 0，则该物品不可选,且若i>n，则需退栈，若此时栈空，则说明无解。

      boolean knapstack(n,MaxW,weight){
        int top=0; i=1; {i为待选物品序号}
        while (MaxW>0) and ( i < = n ) do
          if (MaxW-weight[i]>=0) and ( i < = n ){
           top=top+1; stack[top]:=i;MaxW=MaxW-weight[i];
           }
          {第i件物品装入背包}
          if MaxW=0 { return(true)}
          else{
          if ((i=n) && (top>0)){ {背包内有不合适物品}
           {取栈顶物品，恢复MaxW的值}
          i=stack[top]; top=top-1;MaxW=MaxW+weight[i];
          }
          if （top>0）{
          i=stack[top]; top=top-1;MaxW=MaxW+weight[i];
          }
         i=i+1;
        }
        return(false) {问题无解}
##### 退栈（POP）算法
更新中...
