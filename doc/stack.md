#### 栈是什么？
###### 栈(stack)又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
#### 栈的原理
###### 要明白”栈“原来的意思，如此才能把握其本质，"栈“者,存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法<br>首先系统或者数据结构栈中数据内容的读取与插入（压入push和 弹出pop）是两回事！压入是增加数据，弹出是删除数据 ，这些操作只能从栈顶即最低地址作为约束的接口界面入手操作 ，但读取栈中的数据是随便的没有接口约束之说。很多人都误解这个理念从而对栈产生困惑。而系统栈在计算机体系结构中又起到一个跨部件交互的媒介区域的作用 即 cpu 与内存的交流通道 ，cpu只从系统给我们自己编写的应用程序所规定的栈入口线性地读取执行指令， 用一个形象的词来形容它就是pipeline（管道线、流水线）。cpu内部交互具体参见 EU与BIU的概念介绍。栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。栈是允许在同一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。栈也称为先进后出表。栈可以用来在函数调用的时候存储断点，做递归时要用到栈！在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。在i386机器中，栈顶由称为esp的寄存器进行定位。压栈的操作使得栈顶的地址减小，弹出的操作使得栈顶的地址增大。栈在程序的运行中有着举足轻重的作用。最重要的是栈保存了一个函数调用时所需要的维护信息，这常常称之为堆栈帧或者活动记录。堆栈帧一般包含如下几方面的信息：
###### 1．函数的返回地址和参数
###### 2． 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。<br><img src="/img/2020082322580000.jpg" width=“50%” hight="50%">
#### 栈的基本算法
##### 进栈（PUSH）算法
###### 例如：有一个数列（23，45，3，7，3，945）
      我们先对其进行进栈操作，则进栈顺序为：23，45，3，7，3，945
      我们在对其进行出栈操作，则出栈顺序为：945，3，7，3，45，23
###### 算法思想：括号作用域检查的原则是，对表达式从左到右扫描。当遇到左括号时，左括号入栈；当遇到右括号时，首先将栈顶元素弹出栈，再比较弹出元素是否与右括号匹配，若匹配，则操作继续；否则，查出错误，并停止操作。当表达式全部扫描完毕，若栈为空，说明括号作用域嵌套正确，反之，说明表达式有错误。
###### 示例 问题：假设有n件质量分配为w1，w2，...，wn的物品和一个最多能装载总质量为T的背包，能否从这n件物品中选择若干件物品装入背包，使得被选物品的总质量恰好等于背包所能装载的最大质量，即wi1+wi2+...+wik=T。若能，则背包问题有解，否则无解。
###### 算法思想：首先将n件物品排成一列，依次选取；若装入某件物品后，背包内物品的总质量不超过背包最大装载质量时，则装入（进栈）；否则放弃这件物品的选择，选择下一件物品试探，直至装入的物品总和正好是背包的最大转载质量为止。这时我们称背包装满。若装入若干物品的背包没有满，而且又无其他物品可以选入背包，说明已装入背包的物品中有不合格者，需从背包中取出最后装入的物品（退栈），然后在未装入的物品中挑选，重复此过程，直至装满背包（有解），或无物品可选（无解）为止。
###### 具体实现：设用数组weight[1..N]，stack[1,N]分别存放物品重量和已经装入背包（栈）的物品序号，MaxW表示背包的最大装载量。每进栈一个物品，就从MaxW中减去该物品的质量,设i为待选物品序号,若MaxW-weight[i]>=0，则该物品可选；若MaxW-weight[i] < 0，则该物品不可选,且若i>n，则需退栈，若此时栈空，则说明无解。
      boolean knapstack(n,MaxW,weight){
        int top=0; i=1; {i为待选物品序号}
        while (MaxW>0) and ( i < = n ) do
          if (MaxW-weight[i]>=0) and ( i < = n ){
           top=top+1; stack[top]:=i;MaxW=MaxW-weight[i];
           }
          {第i件物品装入背包}
          if MaxW=0 { return(true)}
          else{
          if ((i=n) && (top>0)){ {背包内有不合适物品}
           {取栈顶物品，恢复MaxW的值}
          i=stack[top]; top=top-1;MaxW=MaxW+weight[i];
          }
          if （top>0）{
          i=stack[top]; top=top-1;MaxW=MaxW+weight[i];
          }
         i=i+1;
        }
        return(false) {问题无解}
 ##### 退栈（POP）算法
#### 栈的实现
##### 定义栈的简单示例：
      定义stack的简单代码：
      stack<int> sta;
      入栈：sta.push(x);
      出栈：sta.pop();
      判断栈的大小： sta.size();
      判断栈是否为空：sta.empty();
###### C++实现：
      classSqStack
      {
      private:
      enum{MaxSize=100};
      intdata[MaxSize];
      inttop;
      public:
      SqStack();
      ~SqStack();
      boolisEmpty();
      voidpushInt(intx);
      intpopInt();
      intgetTop();
      voiddisplay();
      };
      SqStack::SqStack()
      {
      top=-1;
      }
      SqStack::~SqStack(){}
      boolSqStack::isEmpty()//判断栈为空
      {
      return(top==-1);
      }
      voidSqStack::pushInt(intx)//元素进栈
      {
      if(top==MaxSize-1)
      {
      std::cout<<"栈上溢出！"<<std::endl;
      }
      else
      {
      ++top;
      data[top]=x;
      }
      }
      intSqStack::popInt()//退栈
      {
      inttmp=0;
      if(top==-1)
      {
      std::cout<<"栈已空！"<<std::endl;
      }
      else
      {
      tmp=data[top--];
      }
      returntmp;
      }
      intSqStack::getTop()//获得栈顶元素
      {
      inttmp=0;
      if(top==-1)
      {
      std::cout<<"栈空！"<<std::endl;
      }
      else
      {
      tmp=data[top];
      }
      returntmp;
      }
      voidSqStack::display()//打印栈里元素
      {
      std::cout<<"栈中元素："<<std::endl;
      for(intindex=top;index>=0;--index)
      {
      std::cout<<data[index]<<std::endl;
      }
      }
      intmain()
      {
      SqStackst;
      std::cout<<"栈空："<<st.isEmpty()<<std::endl;
      for(inti=1;i<10;i++)
      {
      st.pushInt(i);
      }
      st.display();
      std::cout<<"退一次栈"<<std::endl;
      st.popInt();
      std::cout<<"栈顶元素:"<<st.getTop()<<std::endl;
      st.popInt();
      st.display();
      return0;
      }
