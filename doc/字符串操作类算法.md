##### KMP是什么
KMP全称为Knuth Morris Pratt算法，三个单词分别是三个作者的名字。KMP是一种高效的字符串匹配算法，用来在主字符串中查找模式字符串的位置(比如在"hello,world"主串中查找"world"模式串的位置)。
##### KMP算法的高效体现在哪
高效性是通过和其他字符串搜索算法对比得到的，在这里拿BF(Brute Force)算法做一下对比。BF算法是一种最朴素的暴力搜索算法。它的思想是在主串的[0, n-m]区间内依次截取长度为m的子串，看子串是否和模式串一样(n是主串的长度，m是子串的长度)。BF的时间复杂度是O(N乘以N)，存在很大优化空间。当模式串和主串匹配时，遇到模式串中某个字符不能匹配的情况，对于模式串中已经匹配过的那些字符，如果我们能找到一些规律，将模式串多往后移动几位，而不是像BF算法一样，每次把模式串移动一位，就可以提高算法的效率。比如说在"ababaababacd"中查找"ababac"，可以避免一些字符之间的比较。
##### KMP算法的next数组
明确next数组的含义 : next数组用来存模式串中每个前缀最长的能匹配前缀子串的结尾字符的下标。 next[i] = j 表示下标以i-j为起点，i为终点的后缀和下标以0为起点，j为终点的前缀相等，且此字符串的长度最长。用符号表示为p[0~j] == p[i-j~i]。下面以"ababacd"模式串为例，给出这个串的next数组。
##### 算法流程
举例来说，有一个字符串"BBC ABCDAB ABCDABCDABDE"，我想知道，里面是否包含另一个字符串"ABCDABD"？
* 字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。B与A不匹配，搜索词后移一位。
* 然后第二个字符B与A不匹配，搜索词再往后移。直到字符串有一个字符，与搜索词的第一个字符相同为止。
* 然后比较字符串和搜索词的下一个字符，还是相同。直到字符串有一个字符，与搜索词对应的字符不相同为止，这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把"搜索位置"移到已经比较过的位置，重比一遍。
* 已知空格与D不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：移动位数 = 已匹配的字符数 - 对应的部分匹配值，因为 6 - 2 等于4，所以将搜索词向后移动4位。
* 然后发现空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（"AB"），对应的"部分匹配值"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。
* 然后空格与A不匹配，继续后移一位。
* 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。
* 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。
##### KMP的时间复杂度
KMP的时间复杂度是O(n)。
##### 示例
           /**
             * KMP算法
             *
             * @param ss 主串
             * @param ps 模式串
             * @return 如果找到，返回在主串中第一个字符出现的下标，否则为-1
             */
            public static int KMP(String ss, String ps) {
                char[] s = ss.toCharArray();
                char[] p = ps.toCharArray();
                int i = 0; // 主串的位置
                int j = 0; // 模式串的位置
                int[] next = getNext(ps);
                while (i < s.length && j < p.length) {
                    //①如果j=-1，或者当前字符匹配成功（即S[i]==P[j]），都令i++，j++
                    if (j == -1 || s[i] == p[j]) { // 当j为-1时，要移动的是i，当然j也要归0
                        i++;
                        j++;
                    } else {
                        //②如果j!=-1，且当前字符匹配失败（即S[i]!=P[j]），则令i不变，j=next[j]，j右移j-next[j]
                        j = next[j];
                    }
                }
                if (j == p.length) {
                    return i - j;
                } else {
                    return -1;
                }
            }
