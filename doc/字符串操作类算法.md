#### KMP算法
字符串匹配的KMP算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。许多算法可以完成这个任务，Knuth-Morris-Pratt算法（简称KMP）是最常用的之一。
##### 算法流程
举例来说，有一个字符串"BBC ABCDAB ABCDABCDABDE"，我想知道，里面是否包含另一个字符串"ABCDABD"？
* 字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。B与A不匹配，搜索词后移一位。
* 然后第二个字符B与A不匹配，搜索词再往后移。直到字符串有一个字符，与搜索词的第一个字符相同为止。
* 然后比较字符串和搜索词的下一个字符，还是相同。直到字符串有一个字符，与搜索词对应的字符不相同为止，这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把"搜索位置"移到已经比较过的位置，重比一遍。
* 已知空格与D不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：移动位数 = 已匹配的字符数 - 对应的部分匹配值，因为 6 - 2 等于4，所以将搜索词向后移动4位。
* 然后发现空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（"AB"），对应的"部分匹配值"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。
* 然后空格与A不匹配，继续后移一位。
* 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。
* 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。
##### 示例
           /**
             * KMP算法
             *
             * @param ss 主串
             * @param ps 模式串
             * @return 如果找到，返回在主串中第一个字符出现的下标，否则为-1
             */
            public static int KMP(String ss, String ps) {
                char[] s = ss.toCharArray();
                char[] p = ps.toCharArray();
                int i = 0; // 主串的位置
                int j = 0; // 模式串的位置
                int[] next = getNext(ps);
                while (i < s.length && j < p.length) {
                    //①如果j=-1，或者当前字符匹配成功（即S[i]==P[j]），都令i++，j++
                    if (j == -1 || s[i] == p[j]) { // 当j为-1时，要移动的是i，当然j也要归0
                        i++;
                        j++;
                    } else {
                        //②如果j!=-1，且当前字符匹配失败（即S[i]!=P[j]），则令i不变，j=next[j]，j右移j-next[j]
                        j = next[j];
                    }
                }
                if (j == p.length) {
                    return i - j;
                } else {
                    return -1;
                }
            }
