#### KMP算法
KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。
##### 算法流程
假设现在文本串S匹配到i位置，模式串P匹配到j位置，如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失败时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失败字符所在位置 - 失败字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。 很快，你也会意识到next 数组各值的含义：若k=next[j]，代表模式串P中当前字符之前的字符串中，最前面的k个字符和j之前的最后k个字符是一样的。如果用数学公式来表示是这样的：P[0 ~ k-1] == P[j-k ~ j-1]
此也意味着在某个字符匹配失败时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k > 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。
##### 示例
           /**
             * KMP算法
             *
             * @param ss 主串
             * @param ps 模式串
             * @return 如果找到，返回在主串中第一个字符出现的下标，否则为-1
             */
            public static int KMP(String ss, String ps) {
                char[] s = ss.toCharArray();
                char[] p = ps.toCharArray();
                int i = 0; // 主串的位置
                int j = 0; // 模式串的位置
                int[] next = getNext(ps);
                while (i < s.length && j < p.length) {
                    //①如果j=-1，或者当前字符匹配成功（即S[i]==P[j]），都令i++，j++
                    if (j == -1 || s[i] == p[j]) { // 当j为-1时，要移动的是i，当然j也要归0
                        i++;
                        j++;
                    } else {
                        //②如果j!=-1，且当前字符匹配失败（即S[i]!=P[j]），则令i不变，j=next[j]，j右移j-next[j]
                        j = next[j];
                    }
                }
                if (j == p.length) {
                    return i - j;
                } else {
                    return -1;
                }
            }
