* 定义一个类继承Thread类，并重写Thread类的run()方法，run()方法的方法体就是线程要完成的任务，因此run()称为线程的执行体，创建该类的实例对象，即创建了线程对象，调用线程对象的start()方法来启动线程。
			public class test extends Thread{
			    private int i;
			    public static void main(String[] args) {
				for(int j = 0;j < 50;j++) {

				    //调用Thread类的currentThread()方法获取当前线程
				    System.out.println(Thread.currentThread().getName() + " " + j);

				    if(j == 10) {
					//创建并启动第一个线程
					new test().start();

					//创建并启动第二个线程
					new test().start();
				    }
				}
			    }
			    @Override
			    public void run() {
				for(;i < 100;i++) {
				    //当通过继承Thread类的方式实现多线程时，可以直接使用this获取当前执行的线程
				    System.out.println(this.getName() + " "  + i);
				}
			    }
			}
			
上面程序中getName()返回当前线程的名字，也可以通过setName()方法设置当前线程的名字，程序运行后，至少会创建一个主线程（自动），主线程的线程执行体不是由run()方法确定的，而是由main()方法确定的，在默认情况下，主线程的线程名字为main，用户创建的线程依次为Thread—1、Thread—2、....、Thread—n.<br>
示例中是创建了三个线程：main、Thread-0 、Thread-1，Thread-0 、Thread-1两个线程输出的成员变量i的值不连续（这里的i是实例变量不是局部变量）。通过继承Thread类实现多线程时，每个线程的创建都要创建不同的子类对象，导致Thread-0 、Thread-1两个线程不能共享成员变量 i ，线程的执行是抢占式，并没有说Thread-0 或者Thread-1一直占用CPU（与线程优先级有关，这里Thread-0 、Thread-1线程优先级相同，关于线程优先级的知识这里不做展开）
* 定义一个类实现Runnable接口，创建该类的实例对象obj，将obj作为构造器参数传入Thread类实例对象，这个对象才是真正的线程对象，调用线程对象的start()方法启动该线程。

		public class test implements Runnable{
		    private int i;

		    @Override
		    public  void run() {
			for(;i < 50;i++) {
			    //当线程类实现Runnable接口时，要获取当前线程对象只有通过Thread.currentThread()获取
			    System.out.println(Thread.currentThread().getName() + " " + i);
			}
		    }

		    public static void main(String[] args) {
			for(int j = 0;j < 30;j++) {
			    System.out.println(Thread.currentThread().getName() + " " + j);
			    if(j == 10) {
				test test1 = new test();
				//通过new Thread(target,name)的方式创建线程
				new Thread(test1,"线程1").start();
				new Thread(test1,"线程2").start();
			    }

			}

		    }
线程1和线程2输出的成员变量i是连续的，也就是说通过这种方式创建线程，可以使多线程共享线程类的实例变量。但是，上述程序在运行的时候，发现结果有些并不连续，因为多个线程访问同一资源时，如果资源没有加锁，会出现线程安全问题。

* 创建Callable接口实现类，并实现call()方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值，使用FutureTask对象作为Thread对象的target创建并启动新线程，调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。
	
		public class test{
		    public static void main(String[] args) {
			//这里call()方法的重写是采用lambda表达式，没有新建一个Callable接口的实现类
			FutureTask<Integer> task =  new FutureTask<Integer>((Callable<Integer>)()->{
			    int i = 0;
			    for(;i < 50;i++) {
				System.out.println(Thread.currentThread().getName() +
					"  的线程执行体内的循环变量i的值为：" + i);
			    }
			    //call()方法的返回值
			    return i;
			});

			for(int j = 0;j < 50;j++) {
			    System.out.println(Thread.currentThread().getName() +
				    " 大循环的循环变量j的值为：" + j);
			    if(j == 20) {
				new Thread(task,"有返回值的线程").start();
			    }
			}
			try {
			    System.out.println("子线程的返回值：" + task.get());
			} catch (Exception e) {
			    e.printStackTrace();
			}
		    }
		}
上述程序直接使用Lambda表达式创建Callable对象，call()方法的返回值类型与创建FutureTask对象时<>里的类型一致。也可以通过实现Callable接口，然后创建一个实现类实例的方式创建。
* 通过继承Thread类实现多线程：
 
		优点：实现起来简单，而且要获取当前线程，无需调用Thread.currentThread()方法，直接使用this即可获取当前线程；
		缺点：线程类已经继承Thread类了，就不能再继承其他类；多个线程不能共享同一份资源（如前面分析的成员变量 i ）；

* 通过实现Runnable接口或者Callable接口实现多线程：

		优点：线程类只是实现了接口，还可以继承其他类；多个线程可以使用同一个target对象，适合多个线程处理同一份资源的情况。
		缺点：通过这种方式实现多线程，相较于第一类方式，编程较复杂；要访问当前线程，必须调用Thread.currentThread()方法
#### 线程生命周期的五种状态
*  新建(NEW)：实现Runnable接口和继承Thread类可以得到一个线程类，new一个实例出来，线程就进入了初始状态。
*  就绪(RUNNABLE)：调用线程的start()方法，此线程进入可运行状态 。
*  运行(RUNNING)：调用run方法，此线程进入运行状态，执行程序代码。
*  阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。
直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：

	    1.等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
		线程1获取对象A的锁，正在使用对象A。
		线程1调用对象A的wait()方法。
		线程1释放对象A的锁，并马上进入等待队列。
		锁池里面的对象争抢对象A的锁。
		线程5获得对象A的锁，进入synchronized块，使用对象A。
		线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入锁池。
		线程5调用对象A的notify()方法，唤醒一个线程。
	    2.同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
	    3.其他阻塞：运行(running)的线程执行Thread.sleep(long ms)、运行在当前线程里的其它线程t2调用join()方法、等待用户输入的时候，
	    当前线程进入阻塞状态。当sleep()、join()完成等待线程终止或者超时、用户输入完毕时，线程重新转入可运行(runnable)状态。 

* 死亡(DEAD)：当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，
它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。
#### 什么是线程安全的？
当多个线程访问同一条数据时，不管怎么访问，最终得出的数据结果是正确的，我们就说这个是线程安全的。
#### Volatile原理
Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞因因此volatile变量是一种比sychronized关键字更轻量级的同步机制。<br/>
<img src="/img/20201111224602686-2141387366.png" hight="50%" width="50%"><br/>
当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。
而声明变量是volatile的，JVM保证了每次读变量都从内存中读，跳过CPU cache 这一步。<br/>

	当一个变量定义为 volatile 之后，将具备两种特性：
	1.保证此变量对所有的线程的可见性，当一个线程修改了这个变量的值，volatile保证了新值能立即同步到主内存，
	以及每次使用前立即从主内存刷新。
	但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。
	2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，
	这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），
	只有一个CPU访问内存时，并不需要内存屏障；
	（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。

