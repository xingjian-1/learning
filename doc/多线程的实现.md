
#### 线程生命周期的五种状态
*  新建(NEW)：实现Runnable接口和继承Thread类可以得到一个线程类，new一个实例出来，线程就进入了初始状态。
*  就绪(RUNNABLE)：调用线程的start()方法，此线程进入可运行状态 。
*  运行(RUNNING)：调用run方法，此线程进入运行状态，执行程序代码。
*  阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。
直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：

    (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
	线程1获取对象A的锁，正在使用对象A。
	线程1调用对象A的wait()方法。
	线程1释放对象A的锁，并马上进入等待队列。
	锁池里面的对象争抢对象A的锁。
	线程5获得对象A的锁，进入synchronized块，使用对象A。
	线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入锁池。
	线程5调用对象A的notify()方法，唤醒一个线程。
    (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
    (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)、运行在当前线程里的其它线程t2调用join()方法、等待用户输入的时候，
    当前线程进入阻塞状态。当sleep()、join()完成等待线程终止或者超时、用户输入完毕时，线程重新转入可运行(runnable)状态。 

* 死亡(DEAD)：当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，
它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。
#### 什么是线程安全的？
当多个线程访问同一条数据时，不管怎么访问，最终得出的数据结果是正确的，我们就说这个是线程安全的。
#### Volatile原理
Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞因因此volatile变量是一种比sychronized关键字更轻量级的同步机制。<br/>
<img src="/img/20201111224602686-2141387366.png" hight="50%" width="50%"><br/>
当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。
而声明变量是volatile的，JVM保证了每次读变量都从内存中读，跳过CPU cache 这一步。<br/>
当一个变量定义为 volatile 之后，将具备两种特性：
1.保证此变量对所有的线程的可见性，当一个线程修改了这个变量的值，volatile保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。
2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。<br>

