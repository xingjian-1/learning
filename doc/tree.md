### 树的分类
#### 有序树
##### 二叉树(Binary Tree)
每个节点最多只有两个分支，通常称作左子树或者右子树。
###### 二叉查找树(Binary Search Tree)
                也称为二叉搜索树、有序二叉树或者排序二叉树。
                1.若任意节点的左子树不为空，则左子树上所有节点的值都小于根节点。
                2.若任意节点的右子树不为空，则右子树上所有节点的值都大于等于根节点。
                3.任意节点的左右子树也分别为二叉查找树。
                二叉查找树有个非常严重的问题，如果数据的插入是从小到大插入{1，2，3，4，5}
                或者从大到小插入{5，4，3，2，1}会导致二叉查找树退化称单链表的形式。
                为了解决这个问题，平衡树。
###### 平衡树
                任意节点的子树的高度差都小于等于1。常见的符合平衡树的有AVL树(二叉平衡搜索树)、
                B树(多路平衡搜索树、2-3树、2-3-4树等)、红黑树等。
* AVL树(由发明者Adelson-Velsky和Landis首字母缩写命名)
                任意节点两个子树的高度差不超过1的平衡树。
* B树
                1. 2-3树
                具有两个子节点和一个数据元素的节点称作2节点，具有三个子节点和两个数据元素的节点称作3节点，
                所以整棵树叫做2-3树
                2. 2-3-4树
                包含2个子节点和一个数据元素，包含3个子节点和一个数据元素，包含4个子节点和一个数据元素
                3.2-3-4-5-n的这一类的树统称为B树。
* 红黑树
                根节点是黑色，如果一个节点是红色，则它的子节点必须是黑色，红色节点不连续。
##### 非二叉树
每个节点有两个以上的分支。
#### 无序树

#### 树
`[树]`n(n>=0)个节点的有限集，当n=0时，称为空树，在任意一个非空树中，有如下特点：有且仅有一个的节点称为根节点、当n>1时其余节点可分为m(m>0)个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。
##### `树的遍历`
* 前序：根节点、左子树、右子树 <br><img src="/img/tree_前序.png" width = "20%" height = "10%" alt="图片名称" align=center />
* 中序：左子树、跟节点、右子树 <br><img src="/img/tree_中序.png" width = "20%" height = "10%" alt="图片名称" align=center />
* 后序：左子树、右子树、根节点 <br><img src="/img/tree_后序.png" width = "20%" height = "10%" alt="图片名称" align=center />
##### 二叉树
`二叉树`(binarytree)是树的一种特殊形式。二叉,顾名思义,这种树的每个节点最多有2个孩子节点。注意,这里是最多有2个,也可能只有1个,或者没有孩子节点。`满二叉树`一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。`完全二叉树`对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树 <br><img src="/img/二叉树种类.png" width = "70%" height = "30%" alt="图片名称" align=center />

        二叉树，是由很多个TreeNode构成的这种树形的数据结构
        class TreeNode {
            int value;
            TreeNode left;
            TreeNode right;
        }
就像链表中的 ListNode。二叉树并不一定非得是“二叉”的，而是说每个节点最多有两个孩子，叫 left 和 right，但也可以没有。当每个节点都只有一个孩子的时候，就退化成了链表。所以链表就是一棵特殊的树，而树是一个特殊的图<br><img src='/img/20200826155827.jpg' width="50%" hight="50%">
##### 树的三大特点
        如果把树看成一个无向图，那么它是一个连通图 connected graph.
        树是一个无环图。
        树的节点个数和边的个数之间的关系是固定的。如果树上有 n 个 node，那么它有 n-1条边。因为除了根节点，其他的节点都会有一条边指向它
#### 树的品种
##### 平衡二叉树 Balanced Binary Tree：定义：对于这棵树里的每个节点，它的左子树和右子树的高度差不大于 1。这里要注意，是对于每个节点，而不只是对于根结点。比如左边这棵树就不是平衡二叉树，右边的才是。<br><img src="/img/20200826160745.jpg" width="50%" higth="50%"> <br> 那么大名鼎鼎的 AVL-Tree 就是平衡二叉树，准确说是自平衡二叉查找树。那什么是二叉查找树呢？
##### 二叉查找树
        定义：对于这棵树里的每个节点，
        它左子树里的每个节点的值都小于它的值；
        它右子树里的每个节点的值都大于它的值。
##### 对二叉查找树
最重要的性质就是：在做中序遍历时，这个序列是一个升序序列。当你在做二叉查找树的算法题没有思路时，可以想想这个性质，很多题目都会迎刃而解。<br><img src="/img/20200826161449.jpg" width="50%" higth="50%"> 
##### 完全二叉树
定义：除了最后一层，其他层都是满的，那么最后一层的节点要靠左排列且中间不允许有气泡。比如左边不是完全二叉树，右边的是<br><img src="/img/20200826161612.jpg" width="50%" hight="50%"><br>那么完全二叉树的最大的好处就是因为它排列紧密没有气泡，所以可以用数组来存储，这样就大大节省了内存空间
##### 完美二叉树
定义：所有层的所有节点都必须是满的。完美二叉树比完全二叉树的定义更加严格，包括最后一层，每一层的节点都要是满的，毕竟是追求完美的嘛。所以我们如果知道了层数，就知道了它有多少个节点，也就是一个等比数列求和。<br><img src="/img/20200826161814.jpg" width="50%" hight="50%">
##### 完满二叉树
定义：对于这棵树的每个节点而言，要么有 0 个孩子，要么有 2 个孩子<br><img src="/img/20200826161933.jpg" width="50%" hight="50%">
##### 高度和深度
树的高度 height 和深度 depth 是两个非常重要的概念，比如 Leetcode 104 和 111 就是专门求树的高度的。而这两个概念是相反方向的，大体上呢，高度是从当前节点到叶子 🍃 节点的；深度是从当前节点到根 🌲 节点的。<br><img src="/img/20200826162111.jpg" width="50%" hight="50%">
        定义：从该节点，到以该节点为根节点的这棵树的最远的叶子结点的最长距离。
        核心是，从该节点到最远叶子节点，有几条边。
        这个概念在分析时空复杂度时非常常用，比如在树上做一个递归复杂度是 O(height)。
        为什么呢？
        因为这个距离决定了在 call stack 上有多少层。
        深度 Depth
        定义：从这个节点到根节点的距离。
        这个概念用的比较少，是和高度方向相反的概念
 ###### 遍历 最基本的三种遍历就是
        前序 pre order
        中序 in order
        后序 post order
 ###### 其实这三种遍历方式本质都是一样的，只是输出/打印节点的顺序不同罢了<br><img src="/img/20200826163440.jpg" width="50%" hight="50%">
         public void traverse(TreeNode node) {
          if (root == null) {
            return;
          }
          //preOrder
          print(root.value);

          traverse(root.left); //真正的遍历

          //inOrder
          print(root.value);

          traverse(root.right); //真正的遍历

          //postOrder
          print(root.value);
        }
###### 真正的遍历就这两句话，无论是那种遍历顺序都是不变的，变的只是打印的顺序罢了。
###### 这三种遍历都是深度优先遍历 DFS，而层序遍历是广度优先遍历 BFS。
###### DFS 和 BFS 都是图的基本遍历方式，我之后也会专门写一篇。
###### 那我们来看层序遍历 level order traversal。<br><img src="/img/20200826163612.jpg" width="50%" hight="50%">
###### 输出 5 7 3 1 4.
        参考 Leetcode 102 题。
        也就是每一层按照从左到右的顺序遍历。
        那么还有一种 Zigzag 的遍历方式，就是一行从左到右，下一行从右到左这样子。
######  <br><img src="/img/20200826163711.jpg" width="50%" hight="50%">
###### 输出的就是 5 3 7 1 4.参考 Leetcode 103 题。
###### left/right/vertical/border view，也就是求树的左视图、右视图、俯视图，是非常爱考的一类题，它们是什么意思呢？比如对于这棵树，<br><img src="/img/20200826163902.jpg" width="50%" hight="50%">
###### 左视图 left view：
        就是从左边看的每层的第一个节点。
        [5, 7, 9]
        右视图 right view：
        就是从右边看的每层的第一个节点。
        [5, 3, 8]
        这两个应该比较简单，在层序遍历的时候保留我们需要的值就可以了。
        当然还有其他方法，比如前序遍历可以做左视图，但不是那么的直观，因为你还要判断这个元素是否是当前层的第一个。大家有想法的可以在群里交流哟。（提示：可以再加一个变量
###### 这个视图比前两个稍微难一点，在北美面试中是很爱考的。首先这个图中有一个变量叫 column，根节点为 0，左孩子 - 1，右孩子 + 1。俯视图指的是，从上往下看这棵树，把 column 相同的这些节点放在一个 list 里，从上往下放，然后按照 column 从小到大的顺序排出来。<br><img src="/img/20200826164009.jpg" width="50%" hight="50%"><br>所以对于这棵树，它的俯视图是：[[7], [5, 9], [3], [8]]这题就作为本文的思考题啦，不是很难，大家可以在评论区或者群里交流～
###### Border View在讲完前三种视图之后，这个 border view 想必大家都能猜出来意思了。就是求这棵树的“轮廓”。<br><img src="/img/20200826164121.jpg" width="50%" hight="50%"><br>比如还是这棵树，它的 border view 就是：5, 7, 9, 8, 3这题的大体思路不难，但是细节很多，而且很多条件可能就像我给的这样并没有定义清楚，所以你需要和面试官不断的 clarify 很多细节
