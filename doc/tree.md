#### 二叉树
###### 二叉树，是由很多个 TreeNode 构成的这种树形的数据结构
        class TreeNode {
            int value;
            TreeNode left;
            TreeNode right;
        }
###### 就像链表中的 ListNode。二叉树并不一定非得是“二叉”的，而是说每个节点最多有两个孩子，叫 left 和 right，但也可以没有。当每个节点都只有一个孩子的时候，就退化成了链表。所以链表就是一棵特殊的树，而树是一个特殊的图<br><img src='/img/20200826155827.jpg' width="50%" hight="50%">
###### 树的三大特点
###### 树的三大特点是：
        如果把树看成一个无向图，那么它是一个连通图 connected graph.
        树是一个无环图。
        树的节点个数和边的个数之间的关系是固定的。如果树上有 n 个 node，那么它有 n-1条边。因为除了根节点，其他的节点都会有一条边指向它
###### 树的品种
###### 平衡二叉树 Balanced Binary Tree：定义：对于这棵树里的每个节点，它的左子树和右子树的高度差不大于 1。这里要注意，是对于每个节点，而不只是对于根结点。比如左边这棵树就不是平衡二叉树，右边的才是。<br><img src="/img/20200826160745.jpg" width="50%" higth="50%"> <br> 那么大名鼎鼎的 AVL-Tree 就是平衡二叉树，准确说是自平衡二叉查找树。那什么是二叉查找树呢？
###### 二叉查找树
        定义：对于这棵树里的每个节点，
        它左子树里的每个节点的值都小于它的值；
        它右子树里的每个节点的值都大于它的值。
###### 对二叉查找树，最重要的性质就是：在做中序遍历时，这个序列是一个升序序列。当你在做二叉查找树的算法题没有思路时，可以想想这个性质，很多题目都会迎刃而解。<br><img src="/img/20200826161449.jpg" width="50%" higth="50%"> 
###### 完全二叉树
###### 定义：除了最后一层，其他层都是满的，那么最后一层的节点要靠左排列且中间不允许有气泡。比如左边不是完全二叉树，右边的是<br><img src="/img/20200826161612.jpg" width="50%" hight="50%">
###### 那么完全二叉树的最大的好处就是因为它排列紧密没有气泡，所以可以用数组来存储，这样就大大节省了内存空间
###### 完美二叉树
###### 定义：所有层的所有节点都必须是满的。完美二叉树比完全二叉树的定义更加严格，包括最后一层，每一层的节点都要是满的，毕竟是追求完美的嘛。所以我们如果知道了层数，就知道了它有多少个节点，也就是一个等比数列求和。<br><img src="/img/20200826161814.jpg" width="50%" hight="50%">
###### 完满二叉树
###### 定义：对于这棵树的每个节点而言，要么有 0 个孩子，要么有 2 个孩子<br><img src="/img/20200826161933.jpg" width="50%" hight="50%">
###### 高度和深度
###### 树的高度 height 和深度 depth 是两个非常重要的概念，比如 Leetcode 104 和 111 就是专门求树的高度的。而这两个概念是相反方向的，大体上呢，高度是从当前节点到叶子 🍃 节点的；深度是从当前节点到根 🌲 节点的。<br><img src="/img/20200826162111.jpg" width="50%" hight="50%">
        定义：从该节点，到以该节点为根节点的这棵树的最远的叶子结点的最长距离。
        核心是，从该节点到最远叶子节点，有几条边。
        这个概念在分析时空复杂度时非常常用，比如在树上做一个递归复杂度是 O(height)。
        为什么呢？
        因为这个距离决定了在 call stack 上有多少层。
        深度 Depth
        定义：从这个节点到根节点的距离。
        这个概念用的比较少，是和高度方向相反的概念
 ######
