## 如何做MySQL的性能优化？
· 为搜索字段创建索引、避免使用 select *，列出需要查询的字段、分库分表、合适的存储引擎

## MySQL常用的搜索引擎
![add image](/img/搜索引擎.png)

## MySQL索引的实现原理
索引：高效获取数据的一种数据结构。
验证索引是否生效：explain select * from table where type=1 查询结果rows列的值是1，说明此查询语句扫描了1条记录
索引失效情况：
使用模糊查询，”%“在前面时索引不起作用 explain select * from table where type like '%动物'
使用模糊查询，”%“在后面索引起作用 explain select * from table where type like '动物%'
条件查询中使用or关键字时 索引不起作用 
 > < between等这样的范围查询 索引不起作用
![add image](/img/B+树.png)

## 说一下MySQL的行锁和表锁
MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。
· 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。
· 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。

## 悲观锁(共享锁和排他锁)和乐观锁,
shared lock和exclusive lock（共享锁和排他锁，也叫读锁和写锁，即read lock和write lock）
读锁是共享的，或者说是相互不阻塞的
写锁是排他的，一个写锁会阻塞其他的写锁和读锁
在实际的数据库系统中，每时每刻都发生锁定，当某个用户在修改某部分数据时，mysql会通过锁定阻止其他用户对同一数据的读取

共享锁【S锁】
又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。
这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
 
排他锁【X锁】
又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。
这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

锁的粒度和锁的策略
MySQL有三种锁的级别：页级、表级、行级。
MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎
既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。
MySQL这3种锁的特性可大致归纳如下：
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

## ACID是什么？
· Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。
  事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
· Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
· Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
  事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
· Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
## 说一下数据库的事务隔离
MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：
transaction-isolation = REPEATABLE-READ
可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。
· READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。
· READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。
· REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。
· SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。
脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。
不可重复读 ：是指在一个事务内，多次读同一数据。
幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，
这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，
所有数据行的记录就变多或者变少了。

## 数据库的三范式是什么？
· 第一范式：列不可再分。确保每一列的原子性
· 第二范式：属性完全依赖于主键。
· 第三范式：属性不依赖于其它非主属性，属性直接依赖于主键。
三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，
需求>性能>表结构。所以不能一味的去追求范式建立数据库

## 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几
· 表类型如果是 MyISAM ，那id就是 8。
· 表类型如果是 InnoDB，那id就是 6。
InnoDB 表只会把自增主键的最大id记录在内存中，所以重启之后会导致最大id丢失

## char 和 varchar 的区别是什么？
· char(n) ：固定长度类型，比如订阅 char(10)，当你输入"abc"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。
· chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。
· varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。
· 所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。

## float 和 double 的区别是什么？
· float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。
· double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。

## MySQL的内连接、左连接、右连接有什么区别？
内连接关键字：inner join；左连接：left join；右连接：right join。
内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。
