#### 行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。
* 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
* 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
* 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
* 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
* 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
* 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
* 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
* 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
* 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
* 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
* 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。
#### 策略模式 
策略这个词应该怎么理解，打个比方说，我们出门的时候会选择不同的出行方式，比如骑自行车、坐公交、坐火车、坐飞机、坐火箭等等，这些出行方式，每一种都是一个策略。再比如我们去逛商场，商场现在正在搞活动，有打折的、有满减的、有返利的等等，其实不管商场如何进行促销，说到底都是一些算法，这些算法本身只是一种策略，并且这些算法是随时都可能互相替换的，比如针对同一件商品，今天打八折、明天满100减30，这些策略间是可以互换的。
  
                    public class CashContext {
                        private CashSuper cashSuper;
                        public CashContext(CashSuper cashSuper) {
                            this.cashSuper = cashSuper;
                        }
                        public double getResult(double money) {
                            return cashSuper.acceptCash(money);
                        }
                    }
                    public abstract class CashSuper {
                     public abstract double acceptCash(double money);
                    }
                    //正常收费
                    public abstract class CashSuper {
                     public abstract double acceptCash(double money);
                     }
                    //打折收费
                    public class CashRebate extends CashSuper {
                        private double moneyRebate = 1;    //折扣
                        public CashRebate(double moneyRebate) {
                            this.moneyRebate = moneyRebate;
                        }
                        @Override
                        public double acceptCash(double money) {
                            return money * moneyRebate;
                        }

                    }
                    //返利收费
                    public class CashReturn extends CashSuper {
                        private double moneyConditation = 0.0;    //返利条件
                        private double moneyReturn = 0.0d;    //返利值
                        public CashReturn(double moneyConditation, double moneyReturn) {
                            this.moneyConditation = moneyConditation;
                            this.moneyReturn = moneyReturn;
                        }
                        @Override
                        public double acceptCash(double money) {
                            double result = money;
                            if (money >= moneyConditation) {
                                result = money - Math.floor(money / moneyConditation) * moneyReturn;
                            }
                            return result;
                        }

                    }
                    //测试类
                    public class Client {
                        public static void main(String[] args) {
                            CashContext cashContext = null;
                            Scanner scanner = new Scanner(System.in);
                            System.out.print("请输入打折方式（1/2/3）：");
                            int in = scanner.nextInt();
                            String type = "";
                            switch (in) {
                                case 1:
                                    cashContext = new CashContext(new CashNormal());
                                    type += "正常收费";
                                    break;
                                case 2:
                                    cashContext = new CashContext(new CashReturn(300, 100));
                                    type += "满300返100";
                                    break;
                                case 3:
                                    cashContext = new CashContext(new CashRebate(0.8));
                                    type += "打8折";
                                    break;
                                default:
                                    System.out.println("请输入1/2/3");
                                    break;
                            }
                            double totalPrices = 0;
                            System.out.print("请输入单价：");
                            double price = scanner.nextDouble();
                            System.out.print("请输入数量：");
                            double num = scanner.nextDouble();
                            totalPrices = cashContext.getResult(price * num);
                            System.out.println("单价：" + price + "，数量：" + num + "，类型：" + type + "，合计：" + totalPrices);
                            scanner.close();
                        }
                    }
* 何时使用
一个系统有许多类，而区分它们的只是他们直接的行为时。
* 方法
将这些算法封装成一个一个的类，任意的替换。
* 优点
算法可以自由切换避免使用多重条件判断（如果不用策略模式我们可能会使用多重条件语句，不利于维护）扩展性良好，增加一个策略只需实现接口即可。
* 缺点
策略类数量会增多，每个策略都是一个类，复用的可能性很小所有的策略类都需要对外暴露。
* 使用场景
多个类只有算法或行为上稍有不同的场景，算法需要自由切换的场景，需要屏蔽算法规则的场景。
